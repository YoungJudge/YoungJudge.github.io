<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[小程序学习(八)]]></title>
      <url>/11/WeChatEight/</url>
      <content type="html"><![CDATA[<h2 id="小程序组件之表单组件"><a href="#小程序组件之表单组件" class="headerlink" title="小程序组件之表单组件"></a>小程序组件之表单组件</h2><h4 id="本节知识点"><a href="#本节知识点" class="headerlink" title="本节知识点"></a>本节知识点</h4><ul>
<li>button 按钮</li>
<li>checkbox 复选框</li>
<li>input 输入框</li>
<li>label 单机框</li>
<li>picker 弹出选择</li>
<li>radio  单选框</li>
<li>slider 滑块</li>
<li>switch 开关</li>
<li>form   表单</li>
</ul>
<h4 id="表单之button"><a href="#表单之button" class="headerlink" title="表单之button"></a>表单之button</h4><ul>
<li>loading   类型布尔    名称前是否带loading图标</li>
<li>form-type 类型String  用于<form>组件点击分别会触发<form>组件的submit/reset事件</form></form></li>
<li>open-type 类型contact 进入人工客服</li>
<li>send-message-title 类型String 当前标题  会话内消息卡片标题  必须搭配open-type=”contact”</li>
<li>send-message-path 类型String 当前分享路径  会话内消息卡片点击跳转小程序路径  必须搭配open-type=”contact”</li>
<li>send-message-img 类型String 截图  会话内消息卡片图片  必须搭配open-type=”contact”</li>
<li>show-message-card  类型Boolean 值false 显示会话内消息卡片  必须搭配 opern-type=”contact”</li>
<li>bindcontact   事件名称    客服消息回调   必须搭配 opern-type=”contact”</li>
<li>bindgetphonenumber 事件名称  获取用户手机号回调 open-type=”getphonenumber”</li>
</ul>
<p>关于这个使用说明:</p>
<pre><code>&lt;!--index.html--&gt;
&lt;span style=&quot;font-size:14px;&quot;&gt;&lt;button open-type=&quot;getPhoneNumber&quot; bindgetphonenumber=&quot;getPhoneNumber&quot;&gt;&lt;/button&gt;&lt;/span&gt;
</code></pre><p>但是使用之前必须要调用login方法</p>
<pre><code>App({  
    onLaunch: function () {  
        wx.login({  
            success: function (res) {  
                if (res.code) {  
                    //发起网络请求  
                    console.log(res.code)  
                } else {  
                    console.log(&#39;获取用户登录态失败！&#39; + res.errMsg)  
                }  
            }  
        });  
    }  
})
</code></pre><p>通过bindgetphonenumber绑定的事件来获取回调，回调函数有3个<br>errMsg:用户点击取消或授权的信息回调<br>iv:加密算法的初始向量。(如果用户没有同意授权则是undefined)<br>encrytedData:用户信息的加密数据(如果用户没有同意则返回undefined)</p>
<pre><code>getPhoneNumber: function(e) {
    console.log(e.detail.errMsg);
    console.log(e.detail.iv);
    console.log(e.detail.encryptedData);
    if (e.detail.errMsg == &#39;getPhoneNumber:fail user deny&#39;){
      wx.showModal({
          title: &#39;提示&#39;,
          showCancel: false,
          content: &#39;未授权&#39;,
          success: function (res) { }
      })
    } else {
      wx.showModal({
          title: &#39;提示&#39;,
          showCancel: false,
          content: &#39;同意授权&#39;,
          success: function (res) { }
      })
    }
  }
</code></pre><h4 id="表单之checkbox"><a href="#表单之checkbox" class="headerlink" title="表单之checkbox"></a>表单之checkbox</h4><ul>
<li><p>checkbox-group<br>多项选择器，内部由多个checkbox组成<br>bingchange  类型事件名  说明<checkbox-group>中选项发生改变是触发change事件。detail={value:[选中的checkbox的value的数组]}</checkbox-group></p>
</li>
<li><p>checkbox 最外面必须套一层checkbox-group配合使用 这个标签使用的时候一定要小心。他没有闭口，只有/<br>多选项目<br>value   String  <checkbox>标识，选中时触发<checkbox-group>的 change事件，并携带<checkbox>的value<br>disabled Boolean false   是否禁用<br>checked  Boolean false   当前是否选中，可用来设置默认选中<br>color    Color           checkbox的颜色，同css的color</checkbox></checkbox-group></checkbox></p>
</li>
</ul>
<pre><code>&lt;!--index.html--&gt;
&lt;checkbox-group bindchange=&quot;checkboxChange&quot;&gt;
&lt;label class=&quot;checkcolor&quot; wx:for=&quot;{{items}}&quot;&gt;
&lt;checkbox  value=&quot;{{item.value}}&quot;checked=&quot;{{item.checked}}&quot;/&gt;{{item.name}}
&lt;/label&gt;
&lt;/checkbox-group&gt;
</code></pre><p>index.js文件</p>
<pre><code>  data: {
     items:[
       {&quot;name&quot;:&quot;美国&quot;,&quot;value&quot;:&quot;1&quot;},
        {&quot;name&quot;: &quot;中国&quot;, &quot;value&quot;: &quot;2&quot; },
         {&quot;name&quot;: &quot;韩国&quot;, &quot;value&quot;: &quot;3&quot; },
          {&quot;name&quot;: &quot;日本&quot;, &quot;value&quot;: &quot;4&quot; },
           {&quot;name&quot;: &quot;英国&quot;, &quot;value&quot;: &quot;5&quot; }
     ]
  },
  checkboxChange:function(e){
    console.log(e);
    console.log(e.detail.value);
  }
</code></pre><h4 id="input输入框"><a href="#input输入框" class="headerlink" title="input输入框"></a>input输入框</h4><ul>
<li>value 类型Sting  输入框的初始内容</li>
<li>type  类型String  默认值:text  input类型</li>
<li>password Boolean 默认值false   是否是密码类型</li>
<li>placeholder  String   输入框为空时，占位符</li>
<li>placeholder-style String  指定placeholder的样式</li>
<li>placeholder-class String  指定placeholder的样式类</li>
<li>disabled  Boolean  是否禁用</li>
<li>maxlength Number  140   最大输入长度，设置为-1的时候不限制最大长度</li>
<li>cursor-spacing Number  0  指定光标与键盘的距离  单位PX</li>
<li>confirm-type   String  设置右下角按钮的文字。</li>
<li>confirm-hold   Boolean  false 点击键盘右下角按钮时候是否保持键盘不收起</li>
<li>cursor    Number  指定focus的光标位置</li>
</ul>
<pre><code>&lt;!--input输入框--&gt;
&lt;view class=&quot;section&quot;&gt;
  &lt;input placeholder=&quot;这是一个可以自动聚焦的input&quot; auto-focus/&gt;
&lt;/view&gt;
&lt;view class=&quot;section&quot;&gt;
  &lt;input placeholder=&quot;这个只有在按钮点击的时候才聚焦&quot; focus=&quot;{{focus}}&quot; /&gt;
  &lt;view class=&quot;btn-area&quot;&gt;
    &lt;button bindtap=&quot;bindButtonTap&quot;&gt;使得输入框获取焦点&lt;/button&gt;
  &lt;/view&gt;
&lt;/view&gt;
&lt;view class=&quot;section&quot;&gt;
  &lt;input  maxlength=&quot;10&quot; placeholder=&quot;最大输入长度10&quot; /&gt;
&lt;/view&gt;
&lt;view class=&quot;section&quot;&gt;
  &lt;view class=&quot;section__title&quot;&gt;你输入的是：{{inputValue}}&lt;/view&gt;
  &lt;input  bindinput=&quot;bindKeyInput&quot; placeholder=&quot;输入同步到view中&quot;/&gt;
&lt;/view&gt;
&lt;view class=&quot;section&quot;&gt;
  &lt;input  bindinput=&quot;bindReplaceInput&quot; placeholder=&quot;连续的两个1会变成2&quot; /&gt;
&lt;/view&gt;
&lt;view class=&quot;section&quot;&gt;
  &lt;input password type=&quot;number&quot; /&gt;
&lt;/view&gt;
&lt;view class=&quot;section&quot;&gt;
  &lt;input password type=&quot;text&quot; /&gt;
&lt;/view&gt;
&lt;view class=&quot;section&quot;&gt;
  &lt;input type=&quot;digit&quot; placeholder=&quot;带小数点的数字键盘&quot;/&gt;
&lt;/view&gt;
&lt;view class=&quot;section&quot;&gt;
  &lt;input type=&quot;idcard&quot; placeholder=&quot;身份证输入键盘&quot; /&gt;
&lt;/view&gt;
&lt;view class=&quot;section&quot;&gt;
  &lt;input placeholder-style=&quot;color:red&quot; placeholder=&quot;占位符字体是红色的&quot; /&gt;
&lt;/view&gt;
&lt;!--input输入框结束--&gt;
</code></pre><h4 id="picker"><a href="#picker" class="headerlink" title="picker"></a>picker</h4><p>滚动选择器，现在支持3种选择器，通过mode来区分。分别是普通选择器，时间选择器，日期选择器，默认是普通选择器</p>
<p>普通选择器 mode = selector</p>
<ul>
<li>range  Array  默认值[] 当mode为selector时候，range有效</li>
<li>value  Number 0       当mode为selector时候，是数字，表示了range中的第几个，从0开始</li>
<li>bindchange 事件名称     value改变时候触发change事件。e.detail = {value:value}</li>
</ul>
<p>时间选择器 mode = time<br>多列选择器 mode = multiSelector<br>日期选择器 mode = date<br>省市选择器 mode = region</p>
<h4 id="radio-group-单项选择器同checkbox-group-事件名称-bindchange-“bindchange”"><a href="#radio-group-单项选择器同checkbox-group-事件名称-bindchange-“bindchange”" class="headerlink" title="radio-group  单项选择器同checkbox-group 事件名称:bindchange = “bindchange”"></a>radio-group  单项选择器同checkbox-group 事件名称:bindchange = “bindchange”</h4><p>具体看checkbox</p>
]]></content>
      
        <categories>
            
            <category> 小程序 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 小程序 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[小程序学习(九)]]></title>
      <url>/11/WeChatNine/</url>
      <content type="html"><![CDATA[<h4 id="本节知识点"><a href="#本节知识点" class="headerlink" title="本节知识点"></a>本节知识点</h4><ul>
<li>action-sheet</li>
<li>modal</li>
<li>toast</li>
<li>loading</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 小程序 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 小程序 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[小程序学习(七)]]></title>
      <url>/08/WeChatSeven/</url>
      <content type="html"><![CDATA[<h2 id="小程序-7-之movablearea与coverview"><a href="#小程序-7-之movablearea与coverview" class="headerlink" title="小程序(7)之movablearea与coverview"></a>小程序(7)之movablearea与coverview</h2><h4 id="组件之movable-view"><a href="#组件之movable-view" class="headerlink" title="组件之movable-view"></a>组件之movable-view</h4><ul>
<li>direction  类型string  默认值none   说明movable-view移动的方向，属性值有all.vertical,horizontal,none</li>
<li>inertia    类型Boolean 默认值false  说明movable-view是否带有惯性</li>
<li>out0of-bounds 类型boolean 默认值false  超过可移动区域后，movable-view是否可以移动</li>
<li>x            类型Number   定义X轴向的偏移。如果X的值不在可移动范围内，会自动移动到可移动范围。改变X的值会触发动画。</li>
<li>y            类型Number   定义y轴的偏移。如果y的值不在可移动范围内，会自动移动到可移动范围。改变X的值会触发动画。</li>
<li>damping  类型Number  阻尼系数用于控制X或Y改变时候的动画和过界回弹的动画，值越大移动越快</li>
<li>friction  类型Number 摩擦系数。用于控制惯性滑动的动画。值越大。摩擦力越大。滑动越快停止。必须大于0否则会被设置为默认值</li>
</ul>
<blockquote>
<p>movable-view  必须设置width和height属性，不设置默认为10PX<br>moable-view默认为绝对定位，top和left属性为0px<br>当moable-view小于moanle-area时候，moable-view的移动范围在movable-area内，当movable-view大于moable-area时候<br>movable-view的移动范围必须包含movable-area(X轴和Y轴方向分开考虑)</p>
</blockquote>
<h4 id="注意movable-view必须在组件中，必须是直接子节点否则不能移动"><a href="#注意movable-view必须在组件中，必须是直接子节点否则不能移动" class="headerlink" title="注意movable-view必须在组件中，必须是直接子节点否则不能移动"></a>注意movable-view必须在<movable-area>组件中，必须是直接子节点否则不能移动</movable-area></h4><pre><code>&lt;view &gt;
  &lt;view&gt;movable-view区域小于movable-area&lt;/view&gt;
  &lt;movable-area style=&quot;height: 200px;width: 200px;background: red;&quot;&gt;
    &lt;movable-view style=&quot;height: 50px; width: 50px; background: blue;&quot; x=&quot;{{x}}&quot; y=&quot;{{y}}&quot; direction=&quot;all&quot;&gt;
    &lt;/movable-view&gt;
  &lt;/movable-area&gt;
  &lt;view&gt;
    &lt;button size=&quot;mini&quot; bindtap=&quot;tap&quot;&gt;click me to move to (30px, 30px)&lt;/button&gt;
  &lt;/view&gt;
  &lt;view&gt;movable-view区域大于movable-area&lt;/view&gt;
  &lt;movable-area style=&quot;height: 100px;width: 100px;background: red;&quot; direction=&quot;all&quot;&gt;
    &lt;movable-view style=&quot;height: 200px; width: 200px; background: blue;&quot;&gt;
    &lt;/movable-view&gt;
  &lt;/movable-area&gt;
&lt;/view&gt;
</code></pre><h4 id="cover-view"><a href="#cover-view" class="headerlink" title="cover-view"></a>cover-view</h4><p>覆盖在原生组件上的文本视图，可覆盖的原生组件包括map,video,canvas，支持嵌套类似绝对定位之类的的。（用处不大）</p>
<h4 id="cover-image"><a href="#cover-image" class="headerlink" title="cover-image"></a>cover-image</h4><p>覆盖在源生组件上的图片视图，可覆盖源生组件，同cover-view，支持嵌套</p>
<p>属性名:src 类型String  说明图标路径，支持临时路径，暂时不支持网络地址</p>
<h4 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h4><ul>
<li>只可以嵌套在源生组件map.video,canvas内，避免嵌套在其他组件内</li>
<li>事件模型遵循冒泡模型，但不会冒泡到源生组件</li>
<li>文本建议都套上cover-view标签。避免排版错误</li>
<li>只支持基本的定位，布局，文本样式。不支持设置单边的border,opacity,background-image等.</li>
<li>建议子节点不要溢出父节点</li>
<li>暂时不支持css动画</li>
</ul>
<pre><code>&lt;!--inde.html--&gt;
&lt;video id=&quot;myVideo&quot; src=&quot;http://wxsnsdy.tc.qq.com/105/20210/snsdyvideodownload?filekey=30280201010421301f0201690402534804102ca905ce620b1241b726bc41dcff44e00204012882540400&amp;bizid=1023&amp;hy=SH&amp;fileparam=302c020101042530230204136ffd93020457e3c4ff02024ef202031e8d7f02030f42400204045a320a0201000400&quot; controls=&quot;{{false}}&quot; event-model=&quot;bubble&quot;&gt;
  &lt;cover-view class=&quot;controls&quot;&gt;
    &lt;cover-view class=&quot;play&quot; bindtap=&quot;play&quot;&gt;
      &lt;cover-image class=&quot;img&quot; src=&quot;/path/to/icon_play&quot; /&gt;
    &lt;/cover-view&gt;
    &lt;cover-view class=&quot;pause&quot; bindtap=&quot;pause&quot;&gt;
      &lt;cover-image class=&quot;img&quot; src=&quot;/path/to/icon_pause&quot; /&gt;
    &lt;/cover-view&gt;
    &lt;cover-view class=&quot;time&quot;&gt;00:00&lt;/cover-view&gt;
  &lt;/cover-view&gt;
&lt;/video&gt;
</code></pre><p>index.css</p>
<pre><code>.container{
  display: flex;
  flex-flow: column nowrap;
  justify-content: space-around;
  align-content: space-around;
}
.part1{
  flex: 1 1 100rpx;
  width:100%;
  border-bottom:1px solid #ffffff;
  background:green;
  line-height:100rpx;
  text-align:center;
  color:white;
}
</code></pre><p>index.js</p>
<pre><code>Page({

  /**
   * 页面的初始数据
   */
  data: {
  },
  onReady() {
    this.videoCtx = wx.createVideoContext(&#39;myVideo&#39;)
  },
  play() {
    this.videoCtx.play()
  },
  pause() {
    this.videoCtx.pause()
  }
})
</code></pre>]]></content>
      
        <categories>
            
            <category> 小程序 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 小程序 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[小程序学习(六)]]></title>
      <url>/08/WeChatSix/</url>
      <content type="html"><![CDATA[<h3 id="本节知识点"><a href="#本节知识点" class="headerlink" title="本节知识点"></a>本节知识点</h3><ul>
<li>视图容器</li>
<li>基础内容</li>
<li>表单组件</li>
<li>导航</li>
<li>媒体组件</li>
<li>地图</li>
<li>画布</li>
<li>开放数据</li>
<li>客服会话</li>
</ul>
<p>###（1）组件概述</p>
<p>概述: 框架为开发者提供了一系列基础组件。开发者可以通过这些基础组件快速开发。<br>1.组件是视图层的基本组成单元。<br>2.组件是自带一些功能与微信风格的样式。<br>3.一个组件通常包括开始标签和结束标签。属性用来修饰这个组件。内容在两个标签之内。</p>
<pre><code>&lt;tagname propety=&quot;value&quot;&gt;
Content goes here
&lt;/tagname&gt;
</code></pre><p>如<view>组件就可以如下书写。</view></p>
<pre><code>&lt;view class=&quot;container&quot;&gt;&lt;/view&gt;
</code></pre><p>所有组件与属性都是小写，以连字符-连接。<br>属性:<br>1.属性类型<br>2.共同属性<br>3.特殊属性</p>
<h3 id="（2）视图容器"><a href="#（2）视图容器" class="headerlink" title="（2）视图容器"></a>（2）视图容器</h3><h4 id="view-视图容器"><a href="#view-视图容器" class="headerlink" title="view 视图容器"></a>view 视图容器</h4><ul>
<li>组件之view，view是视图容器。所谓容器就是页面上用来划分区域的块,view就是用来将页面划分块的，使用view，我们可以将一个页面按照我们的需要划分成多个区块。在不同的区块，存放我们相应的内容。类似HTML里面的div</li>
<li>hover-class 类型string  默认值none 指定按下去的样式类。当hover-class = “none”时候，没有点击态效果</li>
<li>hover-stop-propagation 类型Boolean false 指定是否阻止本节点的祖先节点数显点击态</li>
<li>hover-start-time 默认值50  按住后多久出现点击态，单位毫秒</li>
<li>hover-stay-time  默认值400 手指松开后点击态保留时间。单位毫秒</li>
</ul>
<h4 id="scroll-view-可滚动视图的区域"><a href="#scroll-view-可滚动视图的区域" class="headerlink" title="scroll-view 可滚动视图的区域"></a>scroll-view 可滚动视图的区域</h4><ul>
<li><p>组件之scroll-view 这个标签不支持flex布局。<strong>必须要在里面在套一层view标签才可以实现view布局。横向的需要子元素撑开</strong><br> scroll-view具有view相同的功能。但是它是可以滚动的。使用竖向滚动的时候，需要给<scroll-view>一个固定高度,通过wxss设置height</scroll-view></p>
</li>
<li><p>scroll-x<br>类型Boolean   默认值false   允许横向滚动</p>
</li>
<li><p>scroll-y<br>类型Boolean   默认值false   允许纵向滚动</p>
</li>
<li><p>upper-threshold<br>类型Numer 默认值50  距离顶部/左边多远(单位PX)触发scrolltoupper事件</p>
</li>
<li><p>lower-threshold<br> 类型Number 默认值50  距离底部/右边多远(单位PX)触发scrolltolower事件</p>
</li>
<li><p>scroll-top<br>类型Number  设置竖向滚动条位置</p>
</li>
<li><p>scroll-left<br>类型Number 设置横向滚动条位置</p>
</li>
<li><p>scroll-into-view<br>类型String 值应为某子元素id（id不能用数字开头）设置哪个方向可滚动，则在哪个方向滚动到该元素</p>
</li>
<li><p>scroll-with-animation<br>类型Boolean 默认值false 在设置滚动条位置时候使用动画过渡。</p>
</li>
<li><p>enable-back-to-top<br>类型Boolean 默认值是false IOS点击顶部状态栏。安卓双击标题栏，滚动条返回顶部，只支持竖向。</p>
</li>
<li><p>bindscrolltoupper<br>类型EventHandle 滚动到顶部/左边。触发scrolltoupper事件.</p>
</li>
<li><p>bingdscrolltolower<br>类型:EventHandlw滚动到底部/右边。会触发scrolltolower事件</p>
</li>
<li><p>bindscroll<br>类型:EventHandle 滚动时候触发。</p>
</li>
</ul>
<p>使用竖向滚动的时候需要给容器一个固定高度，通过wxss设置height,</p>
<p>下面见实例代码:</p>
<pre><code>index.html文件里面
&lt;!--index.html--&gt;
&lt;view class=&quot;container&quot;&gt;
&lt;!--纵向滚动--&gt;
 &lt;scroll-view scroll-y style=&quot;height:400rpx;&quot; bindscrolltoupper=&quot;upper&quot; bindscrolltolower=&quot;lower&quot; bindscroll=&quot;scroll&quot; scroll-into-view=&quot;{{toView}}&quot; scroll-top=&quot;{{scrollTop}}&quot;&gt;
   &lt;view class=&quot;part1&quot;&gt;
     &lt;view id=&quot;red&quot;class=&quot;scroll-item&quot;&gt;1&lt;/view&gt;
      &lt;view class=&quot;scroll-item&quot;&gt;2&lt;/view&gt;
       &lt;view class=&quot;scroll-item&quot;&gt;3&lt;/view&gt;
        &lt;view class=&quot;scroll-item&quot;&gt;4&lt;/view&gt;
         &lt;view class=&quot;scroll-item&quot;&gt;5&lt;/view&gt;
   &lt;/view&gt;
 &lt;/scroll-view&gt;
&lt;!--纵向滚动结束--&gt;
&lt;view class=&quot;part2&quot;&gt;

&lt;/view&gt;
&lt;!--横向滚动--&gt;
 &lt;scroll-view scroll-x style=&#39;width:100%;&#39;&gt;

   &lt;view class=&quot;part3&quot;&gt;
     &lt;view class=&quot;scroll-item1&quot;&gt;1&lt;/view&gt;
      &lt;view class=&quot;scroll-item1&quot;&gt;2&lt;/view&gt;
       &lt;view class=&quot;scroll-item1&quot;&gt;3&lt;/view&gt;
        &lt;view class=&quot;scroll-item1&quot;&gt;4&lt;/view&gt;
         &lt;view class=&quot;scroll-item1&quot;&gt;5&lt;/view&gt;
   &lt;/view&gt;
&lt;/scroll-view&gt;
&lt;!--横向滚动结束--&gt;
&lt;/view&gt;
</code></pre><p>下面是index.js</p>
<pre><code>//index.js
//获取应用实例
Page({
  data: {
    toView: &#39;red&#39;,
    upper:200,
    scrolltop:200
  }
  top:function(){
    console.log(&quot;距离顶部200的位置&quot;);
  },
  tapMove:function(){
     this.setData({
       scrolltop:this.data.scrolltop+100
     })
  }
})
</code></pre><p>下面是index.wxss文件</p>
<pre><code>.container{
  display: flex;
  flex-flow: column nowrap;
  justify-content: space-around;
  align-content: space-around;
}
.part1{
  flex:1 1 400rpx;
  width:100%;
  background:red;
  display: flex;
  flex-flow: column nowrap;
}
.scroll-item{
  flex: 0 1 200rpx;
  background:blue;
  width:100%;
}
.part2{
  flex:1 1 300rpx;
  width:100%;
  background:yellow;
}
.part3{
  flex:1 1 200rpx;
  width:100%;
  display: flex;
  flex-flow: row nowrap;
}
.scroll-item1{
  flex: 0 0 200rpx;
  border:1px solid white;
  margin-right:10px;
  background:blue;
  height:200rpx;
  background:red;
}
</code></pre><h4 id="Swiper-滑块容器"><a href="#Swiper-滑块容器" class="headerlink" title="Swiper 滑块容器"></a>Swiper 滑块容器</h4><ul>
<li>swiper是滑块视图容器</li>
<li>它可以通过手指对于屏幕的滑动达到切换容器内的效果其中只可以放置<swiper-item>组件，其他节点会被自动删除。</swiper-item></li>
<li>swiper-item仅可放置在<swiper>组件中，宽高设置为100%要是想循环，请把循环加在他的上面wx:for</swiper></li>
</ul>
<h4 id="Swiper属性"><a href="#Swiper属性" class="headerlink" title="Swiper属性"></a>Swiper属性</h4><ul>
<li>indicator-dots<br>类型Boolean 默认值false  说明是否显示面板指示点</li>
<li>autoplay<br>类型Boolean  默认值false  是否自动切换</li>
<li>current<br>类型Number   默认值 0   当前所在页面的index</li>
<li>interval<br>类型Number   默认值 5000 自动切换时间间隔</li>
<li>duration<br>类型Number   默认值 1000 滑动动画时长</li>
<li>bindchange<br>类型EventHandle   current改变时会触发change事件，event.detail = {current:current}</li>
</ul>
<pre><code>&lt;!--swiperhtml文件--&gt;
&lt;!--pages/swiper/swiper.wxml--&gt;
&lt;view class=&quot;container&quot;&gt;
&lt;swiper class=&quot;swiperall&quot; indicator-dots=&#39;{{anniu}}&#39;autoplay=&#39;{{autoplay}}&#39;interval=&#39;{{interval}}&#39;duration=&#39;{{duration}}&#39;&gt;
&lt;swiper-item wx:for=&quot;{{textall}}&quot;&gt;
   &lt;view class=&quot;swiper1&quot;&gt;
        &lt;text&gt;{{item}}&lt;/text&gt;
   &lt;/view&gt;
&lt;/swiper-item&gt;
&lt;/swiper&gt;
&lt;!--按钮开始--&gt;
&lt;view&gt;
 &lt;button type=&quot;primary&quot; bindtap=&quot;changebutton&quot;&gt;changebutton&lt;/button&gt;
 &lt;button type=&quot;primary&quot; bindtap=&quot;changeAutoPlay&quot;&gt;changeAutoPlay&lt;/button&gt;
&lt;/view&gt;
&lt;!--按钮结束--&gt;
&lt;!--滑块开始--&gt;
&lt;view&gt;
 &lt;slider bindchange=&#39;changeInterval&#39;show-value min=&quot;500&quot;max=&quot;2000&quot;&gt;changeInterval&lt;/slider&gt;
  &lt;slider bindchange=&#39;changeduration&#39;show-value min=&quot;1000&quot;max=&quot;10000&quot;&gt;changeDuration&lt;/slider&gt;
&lt;/view&gt;
&lt;!--滑块结束--&gt;
&lt;/view&gt;
</code></pre><p>swiper.css文件</p>
<pre><code>/* pages/swiper/swiper.wxss */
.container{
  display:flex;
  flex-flow: column nowrap;
  justify-content: space-around;
  align-content: space-around;
}
.swiperall{
height:300rpx;
width:100%;
flex-flow:row wrap;
justify-content: space-around;
align-content: space-around;
}
.swiper1{
  width:100%;
  height:100%;
  background:pink;
  font-size: 18px;
  text-align:center;
  color:white;
  line-height:300rpx;
}
</code></pre><p>swiper.js文件</p>
<pre><code>// pages/swiper/swiper.js
Page({

  /**
   * 页面的初始数据
   */
  data: {
       &quot;textall&quot;:[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;],
       &quot;anniu&quot;:true,
       &quot;autoplay&quot;:true,
       &quot;interval&quot;:5000,
       &quot;duration&quot;:1000
  },
  /*轮播开始*/
  changebutton:function(){
    this.setData({
      anniu:!this.data.anniu
    })
  },
  changeAutoPlay:function(){
     this.setData({
       autoplay:!this.data.autoplay
     })
  },
  changeInterval:function(e){
    this.setData({
      interval:e.detail.value
    })
  },
  changeduration:function(e){
      this.setData({
        duration: e.detail.value
      })
  },
  /*轮播结束*/
})
</code></pre><h4 id="自定义轮播-简单来说就是改变swiper上面current的值。但是自定义的就没有办法加定时器了"><a href="#自定义轮播-简单来说就是改变swiper上面current的值。但是自定义的就没有办法加定时器了" class="headerlink" title="自定义轮播 简单来说就是改变swiper上面current的值。但是自定义的就没有办法加定时器了"></a>自定义轮播 简单来说就是改变swiper上面current的值。但是自定义的就没有办法加定时器了</h4><pre><code>&lt;!--pages/lunbo/lunbo.wxml--&gt;
&lt;view class=&quot;container&quot;&gt;
  &lt;view class=&quot;wrap&quot;&gt;
  &lt;!--内容开始--&gt;
  &lt;swiper class=&quot;wrap_content&quot; bindchange=&quot;swiperchange&quot; current=&quot;{{swiperCurrent}}&quot;&gt;
    &lt;swiper-item&gt;
        &lt;view class=&quot;wrap_content_1&quot;&gt;1&lt;/view&gt;
    &lt;/swiper-item&gt;
        &lt;swiper-item&gt;
        &lt;view class=&quot;wrap_content_1&quot;&gt;2&lt;/view&gt;
    &lt;/swiper-item&gt;
        &lt;swiper-item&gt;
        &lt;view class=&quot;wrap_content_1&quot;&gt;3&lt;/view&gt;
    &lt;/swiper-item&gt;
        &lt;swiper-item&gt;
        &lt;view class=&quot;wrap_content_1&quot;&gt;4&lt;/view&gt;
    &lt;/swiper-item&gt;
        &lt;swiper-item&gt;
        &lt;view class=&quot;wrap_content_1&quot;&gt;5&lt;/view&gt;
    &lt;/swiper-item&gt;
  &lt;/swiper&gt;   
    &lt;!--内容结束--&gt;
    &lt;!--左边箭头开始--&gt;
    &lt;view class=&quot;left&quot; bindtap = &quot;Changeleft&quot;&gt;
    左
    &lt;/view&gt;
    &lt;!--左边箭头结束--&gt;
    &lt;!--右边箭头开始--&gt;
     &lt;view class=&quot;right&quot; bindtap = &quot;Changeright&quot;&gt;
    右
     &lt;/view&gt;
    &lt;!--右边箭头结束--&gt;   
  &lt;/view&gt;
&lt;/view&gt;
</code></pre><p>index.js文件</p>
<pre><code>// pages/lunbo/lunbo.js
Page({

  /**
   * 页面的初始数据
   */
  data: {
     swiperCurrent:0
  },
  /*右边按钮开始*/
  Changeright:function(e){
       var swiperindex = this.data.swiperCurrent;
       console.log(swiperindex);
       swiperindex++;
       if(swiperindex&gt;4)
       {
        swiperindex=0;
       }
      this.setData({
        swiperCurrent:swiperindex
      })
  },
  /*左边按钮开始*/
  Changeleft: function (e) {
    var swiperindex = this.data.swiperCurrent;
    console.log(swiperindex);
    swiperindex--;
    if (swiperindex &lt;0) {
      swiperindex = 4;
    }
    this.setData({
      swiperCurrent: swiperindex
    })
  },
  /*给swiper容器绑定好了,只要改变就都改变*/
  swiperchange:function(e){
    this.setData({
      swiperCurrent: e.detail.current
    })
    console.log(this.data.swiperCurrent);
  }
</code></pre><p>index.css</p>
<pre><code>/* pages/lunbo/lunbo.wxss */
.container{
  display: flex;
  flex-flow:column nowrap;
}
.wrap{
  width:100%;
  height:400rpx;
  position:relative;
}
.left{
  position:absolute;
  left:0px;
  width:100rpx;
  height:100rpx;
  top:150rpx;
  background:black;
  color:white;
  line-height:100rpx;
  text-align:center;
}
.right{
  position:absolute;
  right:0px;
  top:150rpx;
  width:100rpx;
  height:100rpx;
  background:black;
  color:white;
  line-height:100rpx;
  text-align:center;
}
.wrap_content{
  width:100%;
  height:400rpx;
  display: flex;
  flex-flow:row nowrap;
}
.wrap_content_1{
  width:100%;
  height:400rpx;
  background:red;
}
</code></pre><h2 id="轮播从上到下"><a href="#轮播从上到下" class="headerlink" title="轮播从上到下"></a>轮播从上到下</h2><p>简单来说就是把vertical这个属性</p>
<pre><code>&lt;!--index.html--&gt;
&lt;view class=&quot;swipershangxia&quot;&gt;
 &lt;swiper class=&quot;swiperall_shang&quot; vertical=&quot;{{true}}&quot; indicator-dots=&quot;{{false}}&quot; autoplay=&quot;{{autoplay}}&quot; interval=&quot;{{interval}}&quot; duration=&quot;{{duration}}&quot;&gt;
     &lt;swiper-item wx:for=&quot;{{textall}}&quot;&gt;
          &lt;view class=&quot;swiper_shu&quot;&gt;
          &lt;text&gt;{{item}}&lt;/text&gt;
          &lt;/view&gt;
     &lt;/swiper-item&gt;
 &lt;/swiper&gt;
&lt;/view&gt;
</code></pre><p>下面是index.css文件</p>
<pre><code>.swipershangxia
{
  flex:1 1 400rpx;
  width:100%;
  background:pink;
}
.swiperall_shang
{
  width:100%;
  height:400rpx;
  display:flex;
  flex-flow:column nowrap;
  justify-content: space-around;
  align-content: space-around;
}
.swiper_shu
{
  width:100%;
  height:400rpx;
  background:#ccc;
  color:white;
  text-align:center;
  line-height:400rpx;
}
</code></pre>]]></content>
      
        <categories>
            
            <category> 小程序 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 小程序 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[小程序学习(五)]]></title>
      <url>/30/WeChatFive/</url>
      <content type="html"><![CDATA[<h2 id="本节知识点"><a href="#本节知识点" class="headerlink" title="本节知识点"></a>本节知识点</h2><ul>
<li>WXML</li>
<li>WXSS</li>
</ul>
<h2 id="WXML"><a href="#WXML" class="headerlink" title="WXML"></a>WXML</h2><p>WXML是框架设计的一套标签语言。可以构建出页面的结构。</p>
<h4 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h4><pre><code>&lt;!--wxml--&gt;
&lt;view&gt;{{message}}&lt;/view&gt;
</code></pre><p>然后在逻辑层</p>
<pre><code>//page.js
Page({
data:{
 message:&quot;Hello!&quot;
}
})
</code></pre><h4 id="循环渲染"><a href="#循环渲染" class="headerlink" title="循环渲染"></a>循环渲染</h4><pre><code>&lt;!--wxml--&gt;
&lt;view wx:for=&quot;{{array}}&quot;&gt;{{item}}&lt;/view&gt;
</code></pre><p>逻辑层代码</p>
<pre><code>Page({
data:{
 array:[1,2,3,4,5]
}
})
</code></pre><h4 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h4><pre><code>&lt;!--wxml--&gt;
&lt;view wx:if=&quot;{{view =='app'}}&quot;&gt;APP&lt;/view&gt;
&lt;view wx:else=&quot;{{view == 'MINA'}}&quot;&gt;&lt;/view&gt;
</code></pre><p>逻辑层</p>
<pre><code>Page({
data:{
   view:&#39;MINA&#39;
}
})
</code></pre><h4 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h4><pre><code>&lt;!--head.wxml--&gt;
&lt;template name = &quot;staffName&quot;&gt;
&lt;view&gt;
FirstName:{{firstName}},LastName:{{lastName}}
&lt;/view&gt;
&lt;/template&gt;
&lt;!--使用页面--&gt;
&lt;import src=&quot;../template/head.wxml&quot;/&gt;
&lt;template is=&quot;staffName&quot; data =&quot;{{staffA}}&quot;&gt;&lt;/template&gt;
</code></pre><p>page.js使用</p>
<pre><code>// page.js
Page({
  data: {
    staffA: {firstName: &#39;Hulk&#39;, lastName: &#39;Hu&#39;},
    staffB: {firstName: &#39;Shang&#39;, lastName: &#39;You&#39;},
    staffC: {firstName: &#39;Gideon&#39;, lastName: &#39;Lin&#39;}
  }
})
</code></pre><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><pre><code>&lt;view bindtap = &quot;add&quot;&gt;{{count}}&lt;/view&gt;
</code></pre><p>在逻辑层里面</p>
<pre><code>Page({
  data: {
    count: 1
  },
  add: function(e) {
    this.setData({
      count: this.data.count + 1
    })
  }
})
</code></pre><h2 id="数据绑定-1"><a href="#数据绑定-1" class="headerlink" title="数据绑定"></a>数据绑定</h2><p>wxml中的动态数据均来自Page中的data</p>
<h4 id="简单绑定"><a href="#简单绑定" class="headerlink" title="简单绑定"></a>简单绑定</h4><p>数据绑定使用双大括号将变量包起来，可以作用于数据</p>
<p>内容</p>
<pre><code>&lt;view&gt;{{message}}&lt;/view&gt;
</code></pre><p>绑定的数据</p>
<pre><code>Page({
 data:{
 message:&quot;Hello&quot;
 }
})
</code></pre><p>组件属性(需要在双括号里)</p>
<pre><code>&lt;view id=&quot;item-{{id}}&quot;&gt;&lt;/view&gt;
</code></pre><p>逻辑层</p>
<pre><code>Page({
 data:{
  id:0
 }
})
</code></pre><h4 id="控制属性-需要在双引号之内"><a href="#控制属性-需要在双引号之内" class="headerlink" title="控制属性(需要在双引号之内)"></a>控制属性(需要在双引号之内)</h4><pre><code>&lt;view wx:if = &quot;{{condition}}&quot;&gt;&lt;/view&gt;
</code></pre><p>逻辑层</p>
<pre><code>Page({
 data:{
  condition:true
 }
})
</code></pre><h4 id="关键字-需要在双引号之内"><a href="#关键字-需要在双引号之内" class="headerlink" title="关键字(需要在双引号之内)"></a>关键字(需要在双引号之内)</h4><pre><code>true : boolean 类型的true ，代表真值
false: boolean 类型的false，代表假值
&lt;checkbox checked = &quot;{{false}}&quot;&gt;&lt;/checkbox&gt;
</code></pre><p>######特别注意:不要直接写checked = “false”,其计算结果是一个字符串，转成BOOLEAN类型后代表真值。</p>
<h4 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h4><p>可以在2个大括号内进行简单的运算，支持方式有如下几种:</p>
<p>三元运算</p>
<pre><code>&lt;view hidden = &quot;{{flag?true:false}}&quot;&gt;Hidden&lt;/view&gt;
</code></pre><p>算数运算</p>
<pre><code>&lt;view&gt;{{a+b}}+{{c}}+d &lt;/view&gt;
</code></pre><p>逻辑层</p>
<pre><code>Page({
data:{
a:1,
b:2,
c:3
}
})
</code></pre><p>view中的内容为3+3+d</p>
<p>逻辑判断</p>
<pre><code>&lt;view wx:if = &quot;{{length>5}}&quot;&gt;&lt;/view&gt;
</code></pre><p>字符串运算</p>
<pre><code>&lt;view&gt;{{"hello"+name}}&lt;/view&gt;
</code></pre><p>逻辑层</p>
<pre><code>Page({
data:{
 name:&#39;MINA&#39;
}
})
</code></pre><p>组合</p>
<p>数组</p>
<pre><code>&lt;view wx:for=&quot;{{[zero,1,2,3,4]}}&quot;&gt;{{item}}&lt;/view&gt;
</code></pre><p>逻辑层</p>
<pre><code>Page({
 data:{
  zero:0
 }
})
</code></pre><p>所以最终的组合就是[0,1,2,3,4]</p>
<h2 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h2><p>wx:for</p>
<p>在组件上使用wx:for控制属性绑定一个数组，可以使用数组中的各项数据重复渲染。<br>默认数组当前项的下标变量名默认是index,数组当前项的变量名是item</p>
<pre><code>&lt;view wx:for = &quot;{{array}}&quot;&gt;
{{index}}:{{item.message}}
&lt;/view&gt;
</code></pre><p>逻辑层代码</p>
<pre><code>Page({
data:{
 array:[
 {
  message:&#39;foo&#39;,
 },
 {
 message:&#39;bar&#39;
 }
 ]
}
})
</code></pre><p>使用 wx:for-item 可以指定数组当前元素的变量名<br>使用 wx:for-index 可以指定数组当前下标的变量名</p>
<pre><code>&lt;view wx:for=&quot;{{array}}&quot; wx:for-index=&quot;idx&quot; wx:for-item=&quot;itemName&quot;&gt;
  {{idx}}: {{itemName.message}}
&lt;/view&gt;
</code></pre><h4 id="事件分类"><a href="#事件分类" class="headerlink" title="事件分类"></a>事件分类</h4><p>事件分为冒泡事件和非冒泡事件</p>
<ul>
<li>冒泡事件:当一个组件上的事件被触发后，该事件会向父节点传递</li>
<li>非冒泡事件:当一个组件上的事件被触发后，该事件不会向父节点传递</li>
</ul>
<h5 id="WXML冒泡事件列表"><a href="#WXML冒泡事件列表" class="headerlink" title="WXML冒泡事件列表"></a>WXML冒泡事件列表</h5><ul>
<li>touchstart 手指触摸开始</li>
<li>touchmove  手指触摸后移动</li>
<li>touchcancel 手指触摸动作被打断，如弹窗，来电提醒等等。</li>
<li>touchend    手指触摸动作结束</li>
<li>tap         手指触摸后马上离开</li>
<li>longpress   手指触摸后，超过350MS在离开，如果指定了事件回调函数并触发了这个事件，tap事件不被触发</li>
<li>longtap     手指触摸后超过350MS在离开(推荐使用longpress代替)</li>
</ul>
<h5 id="以上都属于冒泡事件，其他申明的都是非冒泡事件。如的submit事件等等。"><a href="#以上都属于冒泡事件，其他申明的都是非冒泡事件。如的submit事件等等。" class="headerlink" title="以上都属于冒泡事件，其他申明的都是非冒泡事件。如的submit事件等等。"></a>以上都属于冒泡事件，其他申明的都是非冒泡事件。如<form>的submit事件等等。</form></h5><h5 id="事件绑定和冒泡"><a href="#事件绑定和冒泡" class="headerlink" title="事件绑定和冒泡"></a>事件绑定和冒泡</h5><p>bind事件绑定不会阻止冒泡事件向上冒泡catch事件会阻止事件冒泡</p>
<pre><code>&lt;view id=&quot;outer&quot; bindtap=&quot;handleTap1&quot;&gt;
  outer view
  &lt;view id=&quot;middle&quot; catchtap=&quot;handleTap2&quot;&gt;
    middle view
    &lt;view id=&quot;inner&quot; bindtap=&quot;handleTap3&quot;&gt;
      inner view
    &lt;/view&gt;
  &lt;/view&gt;
&lt;/view&gt;
</code></pre><p>每个事件里面都会接收到一个事件参数。这个参数里面的事件属性就是e，e里面的属性能获取到用户输入的，pagex,pagey等等</p>
<h2 id="WXSS"><a href="#WXSS" class="headerlink" title="WXSS"></a>WXSS</h2><p>类似CSS,与CSS相比我们的拓展属性有:</p>
<ul>
<li>尺寸单位</li>
<li>样式导入</li>
</ul>
<h4 id="尺寸单位"><a href="#尺寸单位" class="headerlink" title="尺寸单位"></a>尺寸单位</h4><p>rpx他依据屏幕宽度自适应。屏幕宽度为750rpx,如果在Iphone6上，屏幕宽度为375px，共有750个物理像素，则750rpx=375px=750 物理像素.1rpx=0.5px=1物理像素</p>
<h4 id="样式导入"><a href="#样式导入" class="headerlink" title="样式导入"></a>样式导入</h4><pre><code>@import &quot;common.wxss&quot;;
.middle-p {
  padding:15px;
}
</code></pre><h4 id="内联样式"><a href="#内联样式" class="headerlink" title="内联样式"></a>内联样式</h4><p>框架上组件支持使用style.class样式.</p>
<ul>
<li>style 静态的样式统一写到class中。style接收动态的样式，在运行时会解析,请尽量避免将静态的样式写进style中，影响渲染速度</li>
</ul>
<pre><code>&lt;view style=&quot;color:{{color}};&quot; /&gt;
</code></pre>]]></content>
      
        <categories>
            
            <category> 小程序 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 小程序 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[小程序学习(四)之逻辑层]]></title>
      <url>/29/WeChatFour/</url>
      <content type="html"><![CDATA[<p>小程序学习(四)之逻辑层(主要说的是对应的js文件)</p>
<h2 id="本节知识点"><a href="#本节知识点" class="headerlink" title="本节知识点:"></a>本节知识点:</h2><ul>
<li><h4 id="注册小程序"><a href="#注册小程序" class="headerlink" title="注册小程序"></a>注册小程序</h4></li>
<li><h4 id="场景值"><a href="#场景值" class="headerlink" title="场景值"></a>场景值</h4></li>
<li><h4 id="注册页面"><a href="#注册页面" class="headerlink" title="注册页面"></a>注册页面</h4></li>
<li><h4 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h4></li>
<li><h4 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h4></li>
<li><h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4></li>
</ul>
<h2 id="App"><a href="#App" class="headerlink" title="App()"></a>App()</h2><p>App()函数用来注册一个小程序，接受一个object参数，其指定小程序的生命周期函数等。</p>
<p>object参数说明:</p>
<ul>
<li><p>onLaunch</p>
<p>类型是function 作用监听小程序初始化，触发时机就是当小程序初始化加载，会触发onLaunch(全局只触发一次)</p>
</li>
<li><p>onReady</p>
<p>类型function 作用监听小程序加载。触发时机当小程序初次渲染完成。</p>
</li>
<li><p>onShow</p>
<p>类型是Function 作用是监听小程序显示。触发时机当小程序启动后，或者从后台进入前台显示，会触发onShow</p>
</li>
<li><p>onHide</p>
<p>类型是Function 作用是监听小程序隐藏，触发时机当小程序从前台进入后台时候，会触发onHide</p>
</li>
<li><p>OnError</p>
<p>类型function  作用错误监听函数 , 当小程序发生脚本错误，或者api调用失败。会触发onError并带上错误信息</p>
</li>
<li><p>其他</p>
<p>类型Any       开发者可以添加任意的函数或者数据到object参数中，用this可以访问</p>
</li>
</ul>
<p>前台，后台定义。当用户点击左上角关闭，或者来电话的时候，小程序并没有直接销毁，而是进入了后台。当再次进入小程序就又会从后台进入前台。<br>特别注意：只有当小程序进入后台一定的时间，或者系统资源占用过高，才会被真正的销毁。</p>
<h2 id="getApp"><a href="#getApp" class="headerlink" title="getApp()"></a>getApp()</h2><p>我们提供了全局的getApp()函数，可以获取到小程序实例</p>
<pre><code>var app = getApp();
console.log(app.globalData)   //I am global data
</code></pre><p>特别注意:App()必须在app.js中注册，且不能是多个<br>不要在定义于App()内的函数调用getApp()使用this 就可以拿到app实例<br>不要在onlauch的时候调用getCurrentPages(),此时page还没有生成<br>通过getApp() 获取到实例后，不要私自调用或者启用生命周期函数</p>
<h2 id="Page"><a href="#Page" class="headerlink" title="Page"></a>Page</h2><p>Page()函数用来注册一个页面，接受一个object参数，其指定的页面的初始数据，生命周期函数，事件处理函数等等</p>
<p>Object参数说明:</p>
<ul>
<li><p>data     类型object    作用页面的初始数据</p>
</li>
<li><p>onLoad   类型Function  作用监听页面加载(只执行一次)</p>
</li>
<li><p>onReady  类型Function  作用监听页面初次渲染完成</p>
</li>
<li><p>onShow   类型Function  作用监听页面显示</p>
</li>
<li><p>onHide   类型Function  作用监听页面隐藏</p>
</li>
<li><p>onUnload 类型Function  作用监听页面卸载</p>
</li>
<li><p>onPullDownRefresh  类型Function 作用监听用户下拉动作</p>
</li>
<li><p>onReachBottom   类型Function   作用页面上拉触底事件的处理函数</p>
</li>
<li><p>onShareAppMessage  类型Function  作用用户点击右上角转发</p>
</li>
<li><p>onPageScroll     类型Function   作用页面滚动触发事件的处理函数</p>
</li>
<li><p>其他           类型 Any         作用开发者可以添加任意的函数或者数据到object参数中。在页面的函数中用this可以访问</p>
</li>
</ul>
<p>示例代码:</p>
<pre><code>//index.js
Page({
  data: {
    text: &quot;This is page data.&quot;
  },
  onLoad: function(options) {
    // Do some initialize when page load.
  },
  onReady: function() {
    // Do something when page ready.
  },
  onShow: function() {
    // Do something when page show.
  },
  onHide: function() {
    // Do something when page hide.
  },
  onUnload: function() {
    // Do something when page close.
  },
  onPullDownRefresh: function() {
    // Do something when pull down.
  },
  onReachBottom: function() {
    // Do something when page reach bottom.
  },
  onShareAppMessage: function () {
   // return custom share data when user share.
  },
  onPageScroll: function() {
    // Do something when page scroll
  },
  // Event handler.
  viewTap: function() {
    this.setData({
      text: &#39;Set some data for updating view.&#39;
    }, function() {
      // this is setData callback
    })
  },
  customData: {
    hi: &#39;MINA&#39;
  }
})
</code></pre><h2 id="初始化数据"><a href="#初始化数据" class="headerlink" title="初始化数据"></a>初始化数据</h2><p>初始化数据将作为页面的第一次渲染。data将会以JSON的形式由逻辑层传输到渲染层。所以数据必须是可以转成JSON格式的。字符串，数字，布尔值，对象，数组</p>
<pre><code>&lt;view&gt;{{text}}&lt;/view&gt;
&lt;view&gt;{{array[0].msg}}&lt;/view&gt;
</code></pre><p>对应的在JS里面的data数据应该写成</p>
<pre><code>Page({
 data:{
  text:&quot;今天&quot;,
  array:[{msg:&#39;1&#39;},{msg:&#39;2&#39;}]
 }
})
</code></pre><h2 id="生命周期函数"><a href="#生命周期函数" class="headerlink" title="生命周期函数"></a>生命周期函数</h2><ul>
<li><h4 id="onLoad-页面加载"><a href="#onLoad-页面加载" class="headerlink" title="onLoad :页面加载"></a>onLoad :页面加载</h4><p>一个页面只会调用一次，可以在onLoad中获取打开当前页面所调用的query参数</p>
</li>
<li><h4 id="onShow-页面显示"><a href="#onShow-页面显示" class="headerlink" title="onShow:页面显示"></a>onShow:页面显示</h4><p>每次打开页面都会调用一次</p>
</li>
<li><h4 id="onReady-页面初次渲染完成"><a href="#onReady-页面初次渲染完成" class="headerlink" title="onReady: 页面初次渲染完成"></a>onReady: 页面初次渲染完成</h4><p>一个页面只会调用一次，代码页面已经准备妥当，可以和视图层交互<br>对界面的设置如:wx.setNavigationBarTitle请在onReady之后设置</p>
</li>
<li><h4 id="onHide-页面隐藏"><a href="#onHide-页面隐藏" class="headerlink" title="onHide 页面隐藏"></a>onHide 页面隐藏</h4><p>当navigateTo或者底部tab切换的时候调用</p>
</li>
<li><h4 id="onUnload-页面卸载"><a href="#onUnload-页面卸载" class="headerlink" title="onUnload: 页面卸载"></a>onUnload: 页面卸载</h4><p>当redirectTo或者navigateBack的时候调用</p>
</li>
</ul>
<h2 id="页面相关事件处理函数"><a href="#页面相关事件处理函数" class="headerlink" title="页面相关事件处理函数"></a>页面相关事件处理函数</h2><ul>
<li><h4 id="onPullDownRefresh-下拉刷新"><a href="#onPullDownRefresh-下拉刷新" class="headerlink" title="onPullDownRefresh :下拉刷新"></a>onPullDownRefresh :下拉刷新</h4><p>（1）监听用户下拉刷新事件。<br>（2）必须需要在app.json的window选项中，或者在页面配置中开启enablePullDownRefresh<br>（3）当处理完数据刷新后。wx.stopPullDownRefresh可以停止当前页面的刷新</p>
</li>
<li><h4 id="onReachBottom-上拉触底"><a href="#onReachBottom-上拉触底" class="headerlink" title="onReachBottom:上拉触底"></a>onReachBottom:上拉触底</h4><p> (1)监听用户上拉触底事件。<br> (2)可以在app.json里面的window选项中或者页面配置中设置触发距离onReachBottomDistance<br> (3)在触发距离内滑动期间，本事件只会触发一次.</p>
</li>
<li><h4 id="onPageScroll：页面滚动"><a href="#onPageScroll：页面滚动" class="headerlink" title="onPageScroll：页面滚动"></a>onPageScroll：页面滚动</h4><p>(1)监听用户滑动页面事件<br>(2)参数为object包含以下字段.<br>  scrollTop    类型Num   页面在垂直方向已滚动的距离(单位Px)<br>(3)代码如下:</p>
<pre><code>onPageScroll:function(options){
  console.log(options.scrollTop);
  }
</code></pre></li>
<li><h4 id="onShareAppMessage-用户转发"><a href="#onShareAppMessage-用户转发" class="headerlink" title="onShareAppMessage : 用户转发"></a>onShareAppMessage : 用户转发</h4><p>(1)只有定义了此事件处理函数，右上角菜单才会显示转发按钮.<br>(2)用户点击转发按钮的时候就会调用<br>(3)此事件需要return一个object用户自定义转发内容</p>
</li>
</ul>
<pre><code>  onShareAppMessage: function () {
  return {
    title: &#39;页面的主标题&#39;,
    desc: &#39;页面的描述&#39;,
    path: &#39;/pages/index/index?id=123&#39;
        }
      }
</code></pre><h2 id="事件处理函数"><a href="#事件处理函数" class="headerlink" title="事件处理函数"></a>事件处理函数</h2><p>(1)除了初始化数据和生命周期函数，我们还可以自定义事件处理函数，在组件中加入事件绑定，当达到触发事件就会执行Page中定义的事件处理函数.</p>
<p>示例代码:</p>
<pre><code>&lt;view bindtap = &quot;clickme&quot;&gt;点击我&lt;/view&gt;
</code></pre><p>在逻辑层(js)</p>
<pre><code>Page({
  clickme:function(){
  console.log(&#39;Hello world!&#39;)
  }
})
</code></pre><h4 id="this-setData"><a href="#this-setData" class="headerlink" title="this.setData()"></a>this.setData()</h4><p>setData 函数用于将数据从逻辑层发送到视图层(异步)，同时改变对应的this.data的值(同步)</p>
<p>setData()参数格式</p>
<ul>
<li><p>data</p>
<p>类型object  必填:是  描述需要改变的数据</p>
</li>
<li><p>callback  类型function 必填:否    描述回调函数</p>
</li>
</ul>
<p>object以key,value的形式表示将this.data中的key对应的值变成value！callback是一个回调函数，在这次setData对界面渲染完毕后使用。<br>其中key可以非常灵活，以数据路径的形式给出。如arr[2].message,a.b.c.d并且不需要再this.data中预先定义.</p>
<blockquote>
<p>注意:<br>直接修改this.data而不调用this.setData 是无法改变页面的状态的。还会造成数据不一致。<br>单次设置的数据不能超过1024KB，避免一次设置过多的数据.</p>
</blockquote>
<p>示例代码:</p>
<pre><code>&lt;view&gt;{{text}}&lt;/view&gt;
&lt;button bindtap=&quot;changeText&quot;&gt; Change normal data &lt;/button&gt;
&lt;view&gt;{{num}}&lt;/view&gt;
&lt;button bindtap=&quot;changeNum&quot;&gt; Change normal num &lt;/button&gt;
&lt;view&gt;{{array[0].text}}&lt;/view&gt;
&lt;button bindtap=&quot;changeItemInArray&quot;&gt; Change Array data &lt;/button&gt;
&lt;view&gt;{{object.text}}&lt;/view&gt;
&lt;button bindtap=&quot;changeItemInObject&quot;&gt; Change Object data &lt;/button&gt;
&lt;view&gt;{{newField.text}}&lt;/view&gt;
&lt;button bindtap=&quot;addNewField&quot;&gt; Add new data &lt;/button&gt;
</code></pre><p>在index.js文件里面</p>
<pre><code>Page({
  data: {
    text: &#39;init data&#39;,
    num: 0,
    array: [{text: &#39;init data&#39;}],
    object: {
      text: &#39;init data&#39;
    }
  },
  changeText: function() {
    // this.data.text = &#39;changed data&#39;  // bad, it can not work
    this.setData({
      text: &#39;changed data&#39;
    })
  },
  changeNum: function() {
    this.data.num = 1
    this.setData({
      num: this.data.num
    })
  },
  changeItemInArray: function() {
    // you can use this way to modify a danamic data path
    this.setData({
      &#39;array[0].text&#39;:&#39;changed data&#39;
    })
  },
  changeItemInObject: function(){
    this.setData({
      &#39;object.text&#39;: &#39;changed data&#39;
    });
  },
  addNewField: function() {
    this.setData({
      &#39;newField.text&#39;: &#39;new data&#39;
    })
  }
})
</code></pre><h2 id="页面路由"><a href="#页面路由" class="headerlink" title="页面路由"></a>页面路由</h2><p>在小程序中所有的页面的路由全部由框架进行管理</p>
<h4 id="getCurrentPages"><a href="#getCurrentPages" class="headerlink" title="getCurrentPages()"></a>getCurrentPages()</h4><p>getCurrentPages()函数用于获取到当前页面栈的实例，以数组形式按栈的顺序给出，第一个元素为首页，最后一个元素为当前页。</p>
<blockquote>
<p>重要的事情说三遍。千万不要修改页面栈。千万不要修改页面栈。千万不要修改页面栈。</p>
</blockquote>
<h4 id="路由方式"><a href="#路由方式" class="headerlink" title="路由方式"></a>路由方式</h4><ul>
<li><p>打开新页面:</p>
<p>调用API wx.navigateTo<br>或者组件<navigator open-type="navigateTo"></navigator></p>
</li>
<li><p>页面重定向</p>
<p>调用API wx.redirecTo<br>或者使用组件<navigator open-type="redirectTo"></navigator></p>
</li>
<li><p>页面返回</p>
<p>调用API wx.navigateBack<br>或者使用组件<navigator open-type="navigateBack"></navigator></p>
</li>
<li><p>Tab切换</p>
<p>调用API wx.switchTab<br>或者使用组件<navigator open-type="switchTab"></navigator></p>
</li>
<li><p>重启动</p>
<p>调用API wx.reLaunch<br>或者使用组件<navigator open-type="reLaunch"></navigator></p>
</li>
</ul>
<p>这几种路由跳转方式。对于前页面来说:<br>wx.navigateTo 对应的 onHide<br>wx.redirecTo  对应的 onUnload<br>wx.navigateBack  对应的onUnload</p>
<h4 id="特别注意"><a href="#特别注意" class="headerlink" title="特别注意"></a>特别注意</h4><ul>
<li>navigateTo,redirectTo只能打开不是底部导航指定的页面</li>
<li>SwitchTab 只能打开tabBar页面</li>
<li>reLaunch   可以打开任意页面</li>
<li>页面底部的tabBar由页面决定，即只要是定义了tabbar的页面，底部就有tabBar</li>
<li>调用页面路由带的参数可以在目标页面的onLoad中获取</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 小程序 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 小程序 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[小程序学习(三)]]></title>
      <url>/24/WeChatThird/</url>
      <content type="html"><![CDATA[<h2 id="小程序总结-三-之目录结构和配置"><a href="#小程序总结-三-之目录结构和配置" class="headerlink" title="小程序总结(三)之目录结构和配置"></a>小程序总结(三)之目录结构和配置</h2><h3 id="本节知识点"><a href="#本节知识点" class="headerlink" title="本节知识点"></a>本节知识点</h3><h4 id="1-目录结构"><a href="#1-目录结构" class="headerlink" title="1.目录结构"></a>1.目录结构</h4><h4 id="2-配置"><a href="#2-配置" class="headerlink" title="2.配置"></a>2.配置</h4><hr>
<h3 id="一-目录结构"><a href="#一-目录结构" class="headerlink" title="(一) 目录结构"></a>(一) 目录结构</h3><p>小程序包含一个描述整体程序的app和多个描述各自页面的page<br>一个小程序主体部分由三个文件组成，必须放在项目的根目录下。</p>
<h4 id="1-app-js"><a href="#1-app-js" class="headerlink" title="(1) app.js"></a>(1) app.js</h4><p>必须需要，他存放的是小程序的业务逻辑</p>
<h4 id="2-app-json"><a href="#2-app-json" class="headerlink" title="(2) app.json"></a>(2) app.json</h4><p>必须需要，他存放的是小程序的公共设置</p>
<h4 id="3-app-wxss"><a href="#3-app-wxss" class="headerlink" title="(3) app.wxss"></a>(3) app.wxss</h4><p>不是必须需要，他是小程序的公共样式表</p>
<h4 id="总结-一个小程序由4个文件组成，分别是"><a href="#总结-一个小程序由4个文件组成，分别是" class="headerlink" title="总结: 一个小程序由4个文件组成，分别是:"></a>总结: 一个小程序由4个文件组成，分别是:</h4><table>
<thead>
<tr>
<th>文件类型</th>
<th style="text-align:center">必填</th>
<th style="text-align:right">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>JS文件</td>
<td style="text-align:center">是</td>
<td style="text-align:right">页面逻辑</td>
</tr>
<tr>
<td>wxml</td>
<td style="text-align:center">是</td>
<td style="text-align:right">页面结构</td>
</tr>
<tr>
<td>wxss</td>
<td style="text-align:center">否</td>
<td style="text-align:right">页面样式表</td>
</tr>
<tr>
<td>json</td>
<td style="text-align:center">否</td>
<td style="text-align:right">页面配置</td>
</tr>
</tbody>
</table>
<h6 id="为了方便开发者减少配置项，我们规定描述页面的这4个文件必须具有相同的路径与文件名。"><a href="#为了方便开发者减少配置项，我们规定描述页面的这4个文件必须具有相同的路径与文件名。" class="headerlink" title="为了方便开发者减少配置项，我们规定描述页面的这4个文件必须具有相同的路径与文件名。"></a>为了方便开发者减少配置项，我们规定描述页面的这4个文件必须具有相同的路径与文件名。</h6><hr>
<h3 id="（二）配置结构"><a href="#（二）配置结构" class="headerlink" title="（二）配置结构"></a>（二）配置结构</h3><p>我们使用app.json文件来对小程序进行全局配置，决定页面文件的路径，窗口表现，设置网络超时时间，设置多Tab等。</p>
<p><img src="http://www.uiyin.com/tuku/weixin/SecondDay/Second1.jpg" alt="小程序配置文件"></p>
<h4 id="app-json配置项列表"><a href="#app-json配置项列表" class="headerlink" title="app.json配置项列表"></a>app.json配置项列表</h4><table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:center">类型</th>
<th style="text-align:right">必填</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>pages</td>
<td style="text-align:center">数组</td>
<td style="text-align:right">是</td>
<td>设置页面路径</td>
</tr>
<tr>
<td>window</td>
<td style="text-align:center">object</td>
<td style="text-align:right">否</td>
<td>设置默认页面的窗口表现</td>
</tr>
<tr>
<td>tabbar</td>
<td style="text-align:center">object</td>
<td style="text-align:right">否</td>
<td>设置底部tab的表现</td>
</tr>
<tr>
<td>networkTimeout</td>
<td style="text-align:center">object</td>
<td style="text-align:right">否</td>
<td>设置网络的超时时间</td>
</tr>
<tr>
<td>debug</td>
<td style="text-align:center">boolean</td>
<td style="text-align:right">否</td>
<td>是否开启debug模式</td>
</tr>
</tbody>
</table>
<h5 id="pages"><a href="#pages" class="headerlink" title="pages"></a>pages</h5><p>接受一个数组，每一项都是字符串，来制定小程序由哪些页面组成的。每一项代表对应页面的【路径+文件名】信息，<strong>数组的第一项代表小程序的初始页面。小程序中新增/减少页面，都需要对pages进行修改.</strong></p>
<p>文件名不需要写文件后缀，因为框架会自动寻找路径.json ,.js ,.wxml,.wxss 的4个文件来整合。</p>
<p>如开发目录</p>
<p>pages/index/index.wxml<br>pages/index/index.js<br>pages/index/index.wxss<br>pages/index/index.json<br>pages/logs/logs.wxml<br>pages/logs/logs.js<br>pages/logs/logs.wxss<br>pages/logs/logs.json</p>
<p>则我们需要在pages中写</p>
<p><img src="http://www.uiyin.com/tuku/weixin/SecondDay/Second2.jpg" alt="小程序配置文件"></p>
<h5 id="window"><a href="#window" class="headerlink" title="window"></a>window</h5><p>用于设置小程序的状态栏，导航条，标题，窗口背景色</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>默认值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>navigationBarBackgroundColor</td>
<td>HexColor</td>
<td>#000000</td>
<td>导航栏背景颜色，如”#000000”</td>
</tr>
<tr>
<td>navigationBarTextStyle</td>
<td>String</td>
<td>white</td>
<td>导航栏标题颜色默认仅支持black/white</td>
</tr>
<tr>
<td>navigationBarTitleText</td>
<td>string</td>
<td></td>
<td>导航栏标题文字内容</td>
</tr>
<tr>
<td>backgroundColor</td>
<td>HexColor</td>
<td>#ffffff</td>
<td>窗口的背景颜色</td>
</tr>
<tr>
<td>backgroundTextStyle</td>
<td>String</td>
<td>dark</td>
<td>下拉背景字体，loading图的样式，仅支持dark/light</td>
</tr>
<tr>
<td>enablePullDownRefresh</td>
<td>Boolean</td>
<td>false</td>
<td>是否开启下拉刷新。</td>
</tr>
<tr>
<td>onReachBottomDistance</td>
<td>Number</td>
<td>50</td>
<td>页面上啦触底事件触发时距离页面底部的距离。单位是PX</td>
</tr>
</tbody>
</table>
<h6 id="HexColor-十六进制-如-”-ff00ff”"><a href="#HexColor-十六进制-如-”-ff00ff”" class="headerlink" title="HexColor (十六进制) 如:”#ff00ff”"></a>HexColor (十六进制) 如:”#ff00ff”</h6><p>如app.json</p>
<p><img src="http://www.uiyin.com/tuku/weixin/SecondDay/Second3.jpg" alt="app.json"><br><img src="http://www.uiyin.com/tuku/weixin/SecondDay/Second4.jpg" alt="演示"></p>
<h5 id="tabbar"><a href="#tabbar" class="headerlink" title="tabbar"></a>tabbar</h5><p>如果我们的小程序是一个多tab应用(客户端串口的底部或者顶部有tab栏目可以切换页面) 那么我们可以通过tabbar配置指定tabbar配置指定tab栏目的表现。以及tab切换时候显示的对应页面。</p>
<p>PS： 当设置为position为top时，将不会显示icon<br>tabbar中的list是一个数组，只能配置最少2个,最多5个tab,tab按数组的顺序排序</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>必填</th>
<th>默认值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>color</td>
<td>HexColor</td>
<td>是</td>
<td></td>
<td>tab上的文字默认颜色</td>
</tr>
<tr>
<td>selectedColor</td>
<td>HexColor</td>
<td>是</td>
<td></td>
<td>tab上的文字选中的颜色</td>
</tr>
<tr>
<td>backgroundColor</td>
<td>HexColor</td>
<td>是</td>
<td></td>
<td>tab的背景色</td>
</tr>
<tr>
<td>borderStyle</td>
<td>String</td>
<td>否</td>
<td>black</td>
<td>tabar上边框的颜色仅仅支持balck,white</td>
</tr>
<tr>
<td>list</td>
<td>数组</td>
<td>是</td>
<td></td>
<td>tab的列表，详见list的属性使用说明，最少2个，最多5个</td>
</tr>
<tr>
<td>position</td>
<td>String</td>
<td>否</td>
<td>bottom</td>
<td>可选top或者bottom</td>
</tr>
</tbody>
</table>
<p>其中list是一个数组,数组中的每一个项都是一个对象，其属性值如下：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>必填</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>pagePath</td>
<td>String</td>
<td>是</td>
<td>页面路径，必须在pages中先定义</td>
</tr>
<tr>
<td>text</td>
<td>String</td>
<td>是</td>
<td>tab上按钮的文字</td>
</tr>
<tr>
<td>iconPath</td>
<td>String</td>
<td>否</td>
<td>图片路径，icon限制为40KB ,建议尺寸81px*81px当position为top时候，icon无效</td>
</tr>
<tr>
<td>selectediconPath</td>
<td>String</td>
<td>否</td>
<td>选中时的图片路径，icon限制为40KB，建议尺寸是81px*81px,当position为top时候，无效</td>
</tr>
</tbody>
</table>
<p><img src="http://www.uiyin.com/tuku/weixin/SecondDay/Second5.jpg" alt="演示"></p>
<h5 id="networkTimeout"><a href="#networkTimeout" class="headerlink" title="networkTimeout"></a>networkTimeout</h5><p>可以设置各种网络请求的超时时间</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>必填</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>request</td>
<td>num</td>
<td>否</td>
<td>wx.request的超时时间，单位毫秒，默认为：60000</td>
</tr>
<tr>
<td>connectSocket</td>
<td>num</td>
<td>否</td>
<td>wx.connectSocket的超时时间，单位毫秒，默认为：60000</td>
</tr>
<tr>
<td>uploadFile</td>
<td>num</td>
<td>否</td>
<td>wx.uploadFile的超时时间，单位毫秒，默认为：60000</td>
</tr>
<tr>
<td>downloadFile</td>
<td>num</td>
<td>否</td>
<td>wx.downloadFile的超时时间，单位毫秒，默认为：60000</td>
</tr>
</tbody>
</table>
<h5 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h5><p>可以在调试模式里开启debug模式，这样在开发者工具面板，调试信息以info形式出现的，其包含的信息由page的注册，页面路由，数据更新，事件触发。可以帮助开发者快速定位</p>
<hr>
<h3 id="每一个页面的page-json"><a href="#每一个页面的page-json" class="headerlink" title="每一个页面的page.json"></a>每一个页面的page.json</h3><p>每一个小程序的页面也可以使用.json文件对本页面的窗口进行配置。页面的配置会覆盖掉app.json里面的内容</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>默认值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>navigationBarBackgroundColor</td>
<td>HexColor</td>
<td>#000000</td>
<td>导航栏背景颜色，如”#000000”</td>
</tr>
<tr>
<td>navigationBarTextStyle</td>
<td>String</td>
<td>white</td>
<td>导航栏标题颜色默认仅支持black/white</td>
</tr>
<tr>
<td>navigationBarTitleText</td>
<td>string</td>
<td></td>
<td>导航栏标题文字内容</td>
</tr>
<tr>
<td>backgroundColor</td>
<td>HexColor</td>
<td>#ffffff</td>
<td>窗口的背景颜色</td>
</tr>
<tr>
<td>backgroundTextStyle</td>
<td>String</td>
<td>dark</td>
<td>下拉背景字体，loading图的样式，仅支持dark/light</td>
</tr>
<tr>
<td>enablePullDownRefresh</td>
<td>Boolean</td>
<td>false</td>
<td>是否开启下拉刷新。</td>
</tr>
<tr>
<td>onReachBottomDistance</td>
<td>Number</td>
<td>50</td>
<td>页面上啦触底事件触发时距离页面底部的距离。单位是PX</td>
</tr>
</tbody>
</table>
<p><img src="http://www.uiyin.com/tuku/weixin/SecondDay/Second6.jpg" alt="解释"></p>
]]></content>
      
        <categories>
            
            <category> 小程序 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 小程序 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[小程序学习(二)]]></title>
      <url>/23/Wechatsecond/</url>
      <content type="html"><![CDATA[<p>本节主要介绍小程序开发工具的使用</p>
<h2 id="本节知识点"><a href="#本节知识点" class="headerlink" title="本节知识点:"></a>本节知识点:</h2><p>(1)  <a href="https://mp.weixin.qq.com/debug/wxadoc/dev/devtools/download.html" target="_blank" rel="external">点击下载工具</a><br>(2)  模拟器<br>(3)  调试工具<br>(4)  小程序操作区<br>(5)  自定义数据上报</p>
<h2 id="第一步-模拟器"><a href="#第一步-模拟器" class="headerlink" title="第一步 模拟器"></a>第一步 模拟器</h2><p>模拟器模拟微信小程序在客户端真实的逻辑表现，对于绝大部分的API均能够在模拟器上呈现正确的状态。</p>
<p><img src="http://www.uiyin.com/tuku/weixin/FirstDay/firstDay6.png" alt="图片1"></p>
<h3 id="编译代码"><a href="#编译代码" class="headerlink" title="编译代码"></a>编译代码</h3><p>点击工具左下角的编译按钮或者使用快捷键ctrl+B 可以编译当前代码，并自动刷新模拟器。<br>同时为了帮助开发者调试具体页面或者进入的场景值，如图：开发者可以选择自定义编译模式。</p>
<p><img src="http://www.uiyin.com/tuku/weixin/FirstDay/firstDay7.png" alt="图片1"></p>
<h2 id="第二步-调试工具"><a href="#第二步-调试工具" class="headerlink" title="第二步 调试工具"></a>第二步 调试工具</h2><p>调试工具分为7大功能板块:Wxml,Console,Sources,Network,Appdata,Storage,Sensor</p>
<h3 id="Wxml-panel"><a href="#Wxml-panel" class="headerlink" title="Wxml panel"></a>Wxml panel</h3><p>Wxml panel 用于帮助开发者开发Wxml转化后的界面，在这里可以看到真实的页面结构以及结构对应的WXSS属性，同时可以通过修改对应wxss属性，在模拟器中实时看到修改的情况。通过调试模块左上角的选择器，还饿可以快速找到页面中对应的wxml代码</p>
<p><img src="http://www.uiyin.com/tuku/weixin/FirstDay/firstDay8.gif" alt="图片1"></p>
<h3 id="Sources-panel"><a href="#Sources-panel" class="headerlink" title="Sources panel"></a>Sources panel</h3><p>Source panel 用于显示当前项目的脚本文件，同浏览器不同，微信小程序框架对脚本文件进行编译的工作，所以在Source panel中开发者看到的文件是经过处理之后的脚本文件，开发者的代码都会包裹在define函数中，并且对于Page代码，在尾部会有require的主动调用。</p>
<p><img src="http://www.uiyin.com/tuku/weixin/FirstDay/firstDay9.png" alt="图片二"></p>
<h3 id="Network-pannel"><a href="#Network-pannel" class="headerlink" title="Network pannel"></a>Network pannel</h3><p>Network Panel 用于观察和现实request和socket的请求情况</p>
<p><img src="http://www.uiyin.com/tuku/weixin/FirstDay/firstDay10.png" alt="图片三"></p>
<blockquote>
<p>注意:uploadFile和downloadFile暂时不支持在Network Panel中查看</p>
</blockquote>
<h3 id="Appdata-panel"><a href="#Appdata-panel" class="headerlink" title="Appdata panel"></a>Appdata panel</h3><p>Appdata panel用于显示当前项目，当前时刻appdata具体数据，实时的反馈项目数据情况，可以在此处编辑数据，并及时的反馈到界面上。</p>
<p><img src="http://www.uiyin.com/tuku/weixin/FirstDay/firstDay10.gif" alt="图片三"></p>
<h3 id="Storage-panel"><a href="#Storage-panel" class="headerlink" title="Storage panel"></a>Storage panel</h3><p>Storage panel 用于显示当前项目使用的wx.setStorage或者wx.setStorageSync后的数据存储情况。<br>（可以理解为本地数据库）</p>
<p><img src="http://www.uiyin.com/tuku/weixin/FirstDay/firstDay11.gif" alt="图片三"></p>
<h3 id="Console-panel"><a href="#Console-panel" class="headerlink" title="Console panel"></a>Console panel</h3><p>(一) 开发者可以再次输入和调试代码</p>
<p><img src="http://www.uiyin.com/tuku/weixin/FirstDay/firstDay12.gif" alt="图片三"></p>
<p>(二)小程序的错误输出，会显示在此处</p>
<p><img src="http://www.uiyin.com/tuku/weixin/FirstDay/firstDay13.png" alt="图片三"></p>
<h3 id="Sensor-panel"><a href="#Sensor-panel" class="headerlink" title="Sensor panel"></a>Sensor panel</h3><p>(一) 开发者可以在这里模拟地理位置</p>
<p><img src="http://www.uiyin.com/tuku/weixin/FirstDay/firstDay14.gif" alt="图片三"></p>
<p>(二) 开发者可以在这里模拟移动设备的表现，用于调试重力感应的API</p>
<p><img src="http://www.uiyin.com/tuku/weixin/FirstDay/firstDay15.gif" alt="图片三"></p>
<h2 id="小程序操作区"><a href="#小程序操作区" class="headerlink" title="小程序操作区"></a>小程序操作区</h2><p>小程序操作区帮助开发者模拟一些客户端的环境操作。例如当用户从小程序回到聊天窗口，会触发一个小程序被设置为后台的api</p>
<p><img src="http://www.uiyin.com/tuku/weixin/FirstDay/firstDay16.png" alt="图片三"></p>
<p>当小程序使用到多窗口的时候，可以在顶部操作区进行页面的切换，需要注意的是这个操作只是为了方便开发者才存在的，在真实的微信客户端不会存在。</p>
<p><img src="http://www.uiyin.com/tuku/weixin/FirstDay/firstDay17.png" alt="图片三"></p>
<h2 id="自定义数据上报"><a href="#自定义数据上报" class="headerlink" title="自定义数据上报"></a>自定义数据上报</h2><p>开发者工具可以编辑和调试自定义分析的数据上报功能，点击菜单栏目的”工具-自定义分析”即可弹窗打开自定义分析</p>
<p><img src="http://www.uiyin.com/tuku/weixin/FirstDay/firstDay18.png" alt="图片三"></p>
<p>在页面中可以新建，查看或者修改事件，再修改的页面中编辑完毕后，点击底部的保存并测试按钮将保存当前的配置，同时工具将在调试器上收到最新配置，并展示的内容包括事件ID的名称，以及每个动作的触发条件和上报数据。</p>
<p><img src="http://www.uiyin.com/tuku/weixin/FirstDay/firstDay19.png" alt="图片三"></p>
<p><img src="http://www.uiyin.com/tuku/weixin/FirstDay/firstDay20.png" alt="图片三"></p>
<p>接着可以在模拟器中操作和触发事件，在模拟器中刷新小程序也将获取该测试配置。除非窗口被关闭。窗口关闭后模拟器不会在收到配置当事件被触发上报时，工具上会展示上报信息，包括事件ID，触发页面，触发方式，触发时动作，以及上报的字段值和数据:</p>
<p><img src="http://www.uiyin.com/tuku/weixin/FirstDay/firstDay21.png" alt="图片三"></p>
<p>同时可以在窗口中点击同步结构，会同步显示上报的数据</p>
<p><img src="http://www.uiyin.com/tuku/weixin/FirstDay/firstDay22.png" alt="图片三"></p>
<p>关闭窗口后，配置项全部失效，模拟器不再受到配置并不再触发上报(小程序中使用wx.reportAnalytics API进行的数据上报，仍会在工具中输出。)测试成功后，可到小程序后台发布事件配置。即可正式生效手机所定义的事件数据。</p>
]]></content>
      
        <categories>
            
            <category> 小程序 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 小程序 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[PS基础(一)]]></title>
      <url>/22/PsBasic/</url>
      <content type="html"><![CDATA[<h2 id="PhotoShop-入门基础"><a href="#PhotoShop-入门基础" class="headerlink" title="PhotoShop 入门基础"></a>PhotoShop 入门基础</h2><p>通过本节的学习对PhotoShop有个大概的了解。</p>
<h2 id="本节知识点"><a href="#本节知识点" class="headerlink" title="本节知识点:"></a>本节知识点:</h2><h3 id="1-PS三要素"><a href="#1-PS三要素" class="headerlink" title="(1) PS三要素"></a>(1) PS三要素</h3><h3 id="2-色彩模式总结"><a href="#2-色彩模式总结" class="headerlink" title="(2) 色彩模式总结"></a>(2) 色彩模式总结</h3><h2 id="第一部分-PhototShop三要素"><a href="#第一部分-PhototShop三要素" class="headerlink" title="第一部分: PhototShop三要素"></a>第一部分: PhototShop三要素</h2><p>PhotoShop 简称PS，它是平面图像合成软件</p>
<h3 id="Ps最主要的就是三点"><a href="#Ps最主要的就是三点" class="headerlink" title="Ps最主要的就是三点:"></a>Ps最主要的就是三点:</h3><p> (1) 色彩    (2) 分辨率   (3) 图层</p>
<h3 id="一-色彩-HSB"><a href="#一-色彩-HSB" class="headerlink" title="(一) 色彩(HSB)"></a>(一) 色彩(HSB)</h3><p>(i) 色相 : 赤橙黄绿青蓝紫 简称 H 特别注意黑和白没有色相</p>
<p>(ii)纯度 : 也叫做饱和度，因为可能有中间色 简称 S</p>
<p>(iii)亮度 : 明与暗 简称 B</p>
<h4 id="1-光的三原色-所有发光体发出的颜色"><a href="#1-光的三原色-所有发光体发出的颜色" class="headerlink" title="(1) 光的三原色(所有发光体发出的颜色)"></a>(1) 光的三原色(所有发光体发出的颜色)</h4><p>红,绿,蓝（简称R,G,B）<br>R G B 里面从0-255 ，一共有256种调色板，所以色彩总共有256<em>256</em>256种，一共有1678万颜色<br>rgb(200,20,70)  //他可能就是偏红色的<br>rgb(255,255,255)  //他就是白色，因为红绿蓝都打开，眼前就是一片白光.  我们管这个叫做加色模式。<br>rgb(50,50,50),rgb(100,100,100) //只要rgb三个值相等，就没有色相，他就是灰色</p>
<h4 id="2-每一种模式对应着一种媒介"><a href="#2-每一种模式对应着一种媒介" class="headerlink" title="(2) 每一种模式对应着一种媒介"></a>(2) 每一种模式对应着一种媒介</h4><h5 id="i-RGB-对应的就是人的肉眼，比如显示器，比如灯泡，一切能发光的物体"><a href="#i-RGB-对应的就是人的肉眼，比如显示器，比如灯泡，一切能发光的物体" class="headerlink" title="(i) RGB 对应的就是人的肉眼，比如显示器，比如灯泡，一切能发光的物体"></a>(i) RGB 对应的就是人的肉眼，比如显示器，比如灯泡，一切能发光的物体</h5><blockquote>
<p>一般网页模式发光的物体都用的是RGB(因为他发光)类似RGB(128,200,278)<br>rgb(255,255,255)形成白光，我们管这个叫加色模式，RGB加色模式</p>
</blockquote>
<h5 id="ii-CMYK-对应的就是青色，品红色，黄色，黑色-专注于印刷体"><a href="#ii-CMYK-对应的就是青色，品红色，黄色，黑色-专注于印刷体" class="headerlink" title="(ii) CMYK 对应的就是青色，品红色，黄色，黑色(专注于印刷体)"></a>(ii) CMYK 对应的就是青色，品红色，黄色，黑色(专注于印刷体)</h5><blockquote>
<p>在这里他与RGB不同的是他是按照百分比来划分的，油墨很浓百分比就高，油墨很淡，百分比就低<br>在cmyk模式下 3个都是0%,0%,0% 他就是白色，3个要都是100% 他就是黑色(但是现在的油墨技术做不到)<br>但是理论上能做得到，所以加个黑色。黑色就是K就是因为B 被RGB抢注了，所以只能用K<br>所以黑色就是(100%,100%,100%,100%)<br>我们管黑色模式就是减色模式。</p>
</blockquote>
<h5 id="我们一般看到的红色不是他本身是红色的。而是他把其他颜色都吸收到了，只有红色给你返回回来，所以你就认为红色。"><a href="#我们一般看到的红色不是他本身是红色的。而是他把其他颜色都吸收到了，只有红色给你返回回来，所以你就认为红色。" class="headerlink" title="我们一般看到的红色不是他本身是红色的。而是他把其他颜色都吸收到了，只有红色给你返回回来，所以你就认为红色。"></a>我们一般看到的红色不是他本身是红色的。而是他把其他颜色都吸收到了，只有红色给你返回回来，所以你就认为红色。</h5><h5 id="特别注意的就是光和色是分不开的。"><a href="#特别注意的就是光和色是分不开的。" class="headerlink" title="特别注意的就是光和色是分不开的。"></a>特别注意的就是光和色是分不开的。</h5><blockquote>
<p>讲复杂点 当你把RGB三色组合在一起的时候，两两交接合成的元素就是青色，品红，黄(印刷三元色)<br>2个加色何在一起组合成一个减色。(红色和绿色相加得到就是黄)（红色和蓝色相加就是品红）（蓝色和绿色相加就是青色）</p>
</blockquote>
<p><img src="http://www.uiyin.com/tuku/PS/PsBasic/PsBasic1.png" alt="三元色"></p>
<h5 id="特别注意的就是青色会把红色完全吸收。"><a href="#特别注意的就是青色会把红色完全吸收。" class="headerlink" title="特别注意的就是青色会把红色完全吸收。"></a>特别注意的就是青色会把红色完全吸收。</h5><h5 id="虚线是相对的，减色会吸收掉加色比如青色会吸收掉红色，品红色会吸收掉绿色，黄色会吸收掉蓝色。品红加绿色还是品红"><a href="#虚线是相对的，减色会吸收掉加色比如青色会吸收掉红色，品红色会吸收掉绿色，黄色会吸收掉蓝色。品红加绿色还是品红" class="headerlink" title="虚线是相对的，减色会吸收掉加色比如青色会吸收掉红色，品红色会吸收掉绿色，黄色会吸收掉蓝色。品红加绿色还是品红"></a>虚线是相对的，减色会吸收掉加色比如青色会吸收掉红色，品红色会吸收掉绿色，黄色会吸收掉蓝色。品红加绿色还是品红</h5><h5 id="所以刚开始工作的时候，需要变成RGB模式，等到了最后一步再转化成CMYK模式。"><a href="#所以刚开始工作的时候，需要变成RGB模式，等到了最后一步再转化成CMYK模式。" class="headerlink" title="所以刚开始工作的时候，需要变成RGB模式，等到了最后一步再转化成CMYK模式。"></a>所以刚开始工作的时候，需要变成RGB模式，等到了最后一步再转化成CMYK模式。</h5><h3 id="（二）分辨率"><a href="#（二）分辨率" class="headerlink" title="（二）分辨率"></a>（二）分辨率</h3><p>(1)分辨率越大越好吗？<br>(2)分辨率的单位究竟是什么</p>
<h4 id="位图和矢量图的区别"><a href="#位图和矢量图的区别" class="headerlink" title="位图和矢量图的区别:"></a>位图和矢量图的区别:</h4><h6 id="位图是基于像素的，而矢量图是基于路径的。"><a href="#位图是基于像素的，而矢量图是基于路径的。" class="headerlink" title="位图是基于像素的，而矢量图是基于路径的。"></a>位图是基于像素的，而矢量图是基于路径的。</h6><p>PS就是基于像素来创建的，所以像素是PS里面的最小单位<br>像素是正方形的，一个像素只能有一个颜色。<br>网页的分辨率一般都是72PPI，意味着每英寸里面有72个像素<br>但是印刷里面必须有300PPI，意味着每英寸有300个像素(因为看的是墨点)<br>后面的一定要接单位<br>PPI每英寸所拥有的像素数目(PPI越高)，表示显示屏能够以越高的密度显示图像，所以PPI越高，细节就越丰富。<br>DPI表示鼠标每移动一英寸在屏幕上移动的点数。</p>
<blockquote>
<p>所以当你以网页72PPI做完图以后，想变成印刷体，你要是强把PPI变成300，你就会发现图片被放大的很多，因为许多没有的颜色他会复制到旁边的颜色作为填充，图片会显得非常模糊。<br>插入值得方式有3种模式:<br>邻近:只对比左右，这样的话速度最快，适合灰色位图<br>两次线性:对比上下左右<br>两次立方:对比上下左右，上左，上右，下左，下右，然后算一个平均值。</p>
</blockquote>
<h6 id="所以色彩要是很丰富的话，两次立方效果会比较好，色彩单一的话，邻近的比较好"><a href="#所以色彩要是很丰富的话，两次立方效果会比较好，色彩单一的话，邻近的比较好" class="headerlink" title="所以色彩要是很丰富的话，两次立方效果会比较好，色彩单一的话，邻近的比较好"></a>所以色彩要是很丰富的话，两次立方效果会比较好，色彩单一的话，邻近的比较好</h6><h6 id="所以要做1010印刷体的话，则必须尺寸变成10-610-6，分辨率变成300，因为印刷体要做上下，3MM的填充"><a href="#所以要做1010印刷体的话，则必须尺寸变成10-610-6，分辨率变成300，因为印刷体要做上下，3MM的填充" class="headerlink" title="所以要做1010印刷体的话，则必须尺寸变成10.610.6，分辨率变成300，因为印刷体要做上下，3MM的填充"></a>所以要做10<em>10印刷体的话，则必须尺寸变成10.6</em>10.6，分辨率变成300，因为印刷体要做上下，3MM的填充</h6><h6 id="如果非要在原图上修改的话，只有牺牲长度和宽度，把重定向图像宽度和高度去掉，这样就变成了一个缩略图。"><a href="#如果非要在原图上修改的话，只有牺牲长度和宽度，把重定向图像宽度和高度去掉，这样就变成了一个缩略图。" class="headerlink" title="如果非要在原图上修改的话，只有牺牲长度和宽度，把重定向图像宽度和高度去掉，这样就变成了一个缩略图。"></a>如果非要在原图上修改的话，只有牺牲长度和宽度，把重定向图像宽度和高度去掉，这样就变成了一个缩略图。</h6><p><img src="http://www.uiyin.com/tuku/PS/PsBasic/PsBasic3.png" alt="三元色"></p>
<p>上图就意味着 66乘以44乘以72乘以72 = 4752乘以3168 ，无论怎么变化像素的总值是不变的。</p>
<h3 id="（三）图层"><a href="#（三）图层" class="headerlink" title="（三）图层"></a>（三）图层</h3><p>图层后续会详细说到，先说个印象。每一个图层就是每一张纸，然后很多张纸叠在一起就是最后的效果。</p>
]]></content>
      
        <categories>
            
            <category> PhotoShop基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> PSBasic </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[小程序学习(一)]]></title>
      <url>/22/Wechatfirst/</url>
      <content type="html"><![CDATA[<p>通过本节的学习对小程序有个大概的认识和了解，具体见本节知识点。</p>
<h2 id="本节知识点"><a href="#本节知识点" class="headerlink" title="本节知识点"></a>本节知识点</h2><ul>
<li>初步了解小程序</li>
<li>下载开发工具</li>
<li>获取APPID</li>
<li>了解对应文件的作用</li>
</ul>
<h2 id="小程序的概述"><a href="#小程序的概述" class="headerlink" title="小程序的概述"></a>小程序的概述</h2><p>微信小程序是运行在微信环境中的应用，它只能在微信中运行。不能运行在浏览器中，微信小程序提供了专门的开发工具。用于微信小程序的开发，还提供了丰富的API，让我们的小程序能够具备与手机设计和微信交互的能力。比如获取摄像头拍照，访问文件系统等等。那么与微信交互主要体现在三个方面</p>
<ul>
<li>获取登录微信用户的用户信息</li>
<li>微信支付</li>
<li>使用模板消息向微信发送通知消息</li>
</ul>
<h2 id="第一步-获取开发小程序的APPID"><a href="#第一步-获取开发小程序的APPID" class="headerlink" title="第一步 获取开发小程序的APPID"></a>第一步 获取开发小程序的APPID</h2><ul>
<li>点击<a href="https://mp.weixin.qq.com/cgi-bin/registermidpage?action=index&amp;lang=zh_CN" target="_blank" rel="external">注册</a>选择小程序即可。这里需要用户手拿身份证注册拍照，获取认证。具体步骤请见百度</li>
<li>点击 <a href="https://mp.weixin.qq.com" target="_blank" rel="external">登陆</a>就可在网站的”设置” - “开发者设置”中，查看到微信小程序的AppId,注意不可直接使用服务号或者订阅号的APPID</li>
</ul>
<p><img src="http://www.uiyin.com/tuku/weixin/FirstDay/firstDay4.png" alt="查到APPID"></p>
<p>注意:如果要以非管理员微信号上在手机上体验该小程序，那么必须还需要操作”绑定开发者”，即在用户身份，“开发者”模块，绑定需要体验该小程序的微信号。本教程默认注册账号，体验都是使用管理员微信号</p>
<h2 id="第二步-下载小程序的开发工具"><a href="#第二步-下载小程序的开发工具" class="headerlink" title="第二步 下载小程序的开发工具"></a>第二步 下载小程序的开发工具</h2><ul>
<li>为了更简单，更方便的开发小程序只有使用微信自带的开发者工具了，WeStrom,SublimeText，等等都不支持. <a href="https://mp.weixin.qq.com/debug/wxadoc/dev/devtools/download.html" target="_blank" rel="external">点击下载此工具</a></li>
<li>安装不用多说了。直接下一步就好了。安装好以后每次登陆的时候必须要联网，必须要扫码。单机无法操作 具体使用步骤请看第二节开发工具的使用 </li>
</ul>
<h2 id="第三步-创建第一个项目"><a href="#第三步-创建第一个项目" class="headerlink" title="第三步 创建第一个项目"></a>第三步 创建第一个项目</h2><ul>
<li>当用微信扫码登陆，选择创建”项目”，填入刚才获取的APPID，设置一个本地项目的名称(非小程序名称),比如”我的第一个项目”，并选择一个本地的文件夹作为代码的存储的目录，点击”新建项目”就可以了.</li>
<li>在创建过程中，如果选择的本地文件夹是个空文件夹，开发者工具会提示：是否需要创建一个quick start目录，在这个项目上选择勾，开发者工具会自动在开发目录里生成一个简单的demo</li>
</ul>
<p><img src="http://www.uiyin.com/tuku/weixin/FirstDay/firstDay4.png" alt="创建项目"></p>
<h2 id="第四步-简要说说个个文件的作用。后续会说明的。"><a href="#第四步-简要说说个个文件的作用。后续会说明的。" class="headerlink" title="第四步 简要说说个个文件的作用。后续会说明的。"></a>第四步 简要说说个个文件的作用。后续会说明的。</h2><p><img src="http://www.uiyin.com/tuku/weixin/FirstDay/firstDay4.png" alt="文件的作用"></p>
<h3 id="小程序项目在根目录必不可少的3个文件"><a href="#小程序项目在根目录必不可少的3个文件" class="headerlink" title="小程序项目在根目录必不可少的3个文件:"></a>小程序项目在根目录必不可少的3个文件:</h3><ul>
<li>app.js </li>
<li>app.json </li>
<li>app.wxss </li>
</ul>
<hr>
<h3 id="app-js"><a href="#app-js" class="headerlink" title="app.js"></a>app.js</h3><p>app.js是小程序的脚本代码，我们可以在文件中监听并处理小程序的生命周期函数，声明全局变量，调用框架提供的丰富的API，具体的后续请参照小程序API文档。</p>
<pre><code>//app.js
App({
  onLaunch: function () {
    // 展示本地存储能力
    var logs = wx.getStorageSync(&#39;logs&#39;) || []
    logs.unshift(Date.now())
    wx.setStorageSync(&#39;logs&#39;, logs)

    // 登录
    wx.login({
      success: res =&gt; {
        // 发送 res.code 到后台换取 openId, sessionKey, unionId
      }
    })
    // 获取用户信息
    wx.getSetting({
      success: res =&gt; {
        if (res.authSetting[&#39;scope.userInfo&#39;]) {
          // 已经授权，可以直接调用 getUserInfo 获取头像昵称，不会弹框
          wx.getUserInfo({
            success: res =&gt; {
              // 可以将 res 发送给后台解码出 unionId
              this.globalData.userInfo = res.userInfo

              // 由于 getUserInfo 是网络请求，可能会在 Page.onLoad 之后才返回
              // 所以此处加入 callback 以防止这种情况
              if (this.userInfoReadyCallback) {
                this.userInfoReadyCallback(res)
              }
            }
          })
        }
      }
    })
  },
  globalData: {
    userInfo: null
  }
})
</code></pre><h3 id="app-json"><a href="#app-json" class="headerlink" title="app.json"></a>app.json</h3><p>app.json是对整个小程序的全局配置。我们可以在这个文件中配置小程序是由哪些页面组成，配置小程序的窗口背景色，配置导航条样式，配置默认标题。（JSON包）</p>
<blockquote>
<h4 id="重要的事情说三遍。这里特别注意不可以加任何注释！-不能加任何注释-不能加任何注释"><a href="#重要的事情说三遍。这里特别注意不可以加任何注释！-不能加任何注释-不能加任何注释" class="headerlink" title="重要的事情说三遍。这里特别注意不可以加任何注释！ 不能加任何注释! 不能加任何注释!"></a>重要的事情说三遍。这里特别注意不可以加任何注释！ 不能加任何注释! 不能加任何注释!</h4></blockquote>
<pre><code>{
  &quot;pages&quot;:[
    &quot;pages/index/index&quot;,
    &quot;pages/logs/logs&quot;
  ],
  &quot;window&quot;:{
    &quot;backgroundTextStyle&quot;:&quot;light&quot;,
    &quot;navigationBarBackgroundColor&quot;: &quot;#fff&quot;,
    &quot;navigationBarTitleText&quot;: &quot;WeChat&quot;,
    &quot;navigationBarTextStyle&quot;:&quot;black&quot;
  }
}
</code></pre><h3 id="app-wxss"><a href="#app-wxss" class="headerlink" title="app.wxss"></a>app.wxss</h3><p>app.wxss是整个小程序的公共样式表。我们可以在页面组件的class属性上直接使用app.wxss样式规则<br>(类似里面的CSS文件)</p>
<pre><code>/**app.wxss**/
.container {
  height: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: space-between;
  padding: 200rpx 0;
  box-sizing: border-box;
}
</code></pre><hr>
<p>上面3个是通配每见一个小程序都必须要有的。下面说的是单独怎么建页面</p>
<hr>
<h2 id="自创页面"><a href="#自创页面" class="headerlink" title="自创页面"></a>自创页面</h2><p>自创的页面都只能在pages目录下面。微信小程序的每一个页面的[路径+页面名]都需要写在app.json的pages中，且pages中的第一个页面是小程序的首页.</p>
<p>每一个小程序是由同路径下同名的四个不同后缀文件的组成：如index.js,index.wxml,index.wxss,index.json<br>.js后缀的文件是脚本文件。<br>.json后缀的文件是配置文件<br>.wxss后缀是样式表文件<br>.wxml后缀的文件就是页面结构文件.</p>
<p>index.wxml是页面的结构文件</p>
<pre><code>&lt;!--index.wxml--&gt;
&lt;view class=&quot;container&quot;&gt;
  &lt;view class=&quot;userinfo&quot;&gt;
    &lt;block wx:if=&quot;{{hasUserInfo}}&quot;&gt;
      &lt;image bindtap=&quot;bindViewTap&quot; class=&quot;userinfo-avatar&quot; src=&quot;{{userInfo.avatarUrl}}&quot; background-size=&quot;cover&quot;&gt;&lt;/image&gt;
      &lt;text class=&quot;userinfo-nickname&quot;&gt;{{userInfo.nickName}}&lt;/text&gt;
    &lt;/block&gt;
    &lt;button wx:else open-type=&quot;getUserInfo&quot; bindgetuserinfo=&quot;getUserInfo&quot;&gt; 获取头像昵称 &lt;/button&gt;
  &lt;/view&gt;
  &lt;view class=&quot;usermotto&quot;&gt;
    &lt;text class=&quot;user-motto&quot;&gt;{{motto}}&lt;/text&gt;
  &lt;/view&gt;
&lt;/view&gt;
</code></pre><p>本例中使用了<view> <image> <text>来搭建页面结构，绑定数据和交互处理函数。</text></image></view></p>
<p>index.js是页面的脚本文件，在这个文件中我们可以监听并处理页面的生命周期函数，获取小程序实例，声明并处理数据，响应页面交互事件等。</p>
<pre><code>//index.js
//获取应用实例
const app = getApp()

Page({
  data: {
    motto: &#39;Hello World&#39;,
    userInfo: {},
    hasUserInfo: false
  },
  //事件处理函数
  bindViewTap: function() {
    wx.navigateTo({
      url: &#39;../logs/logs&#39;
    })
  },
  onLoad: function () {
    if (app.globalData.userInfo) {
      this.setData({
        userInfo: app.globalData.userInfo,
        hasUserInfo: true
      })
    } else {
      // 由于 getUserInfo 是网络请求，可能会在 Page.onLoad 之后才返回
      // 所以此处加入 callback 以防止这种情况
      app.userInfoReadyCallback = res =&gt; {
        this.setData({
          userInfo: res.userInfo,
          hasUserInfo: true
        })
      }
    }
  },
  getUserInfo: function(e) {
    this.setData({
      userInfo: e.detail.userInfo,
      hasUserInfo: true
    })
  }
})
</code></pre><p>index.wxss是页面的样式表:</p>
<pre><code>/**index.wxss**/
.userinfo {
  display: flex;
  flex-direction: column;
  align-items: center;
}

.userinfo-avatar {
  width: 128rpx;
  height: 128rpx;
  margin: 20rpx;
  border-radius: 50%;
}

.userinfo-nickname {
  color: #aaa;
}

.usermotto {
  margin-top: 200px;
}
</code></pre><p>页面的样式表是非必要的，当有页面样式表时，页面的样式表中的样式规则会层叠覆盖app.wxss中的样式规则，如果不指定页面的样式表，也可以在页面的结构文件中直接使用app.wxss中指定的样式规则</p>
<p>index.json是页面的配置文件</p>
<p>页面的配置文件是非必要的。当有页面的配置文件时，配置项在该页面会覆盖app.json的window中相同的配置项。如果没有指定的页面配置文件，则在该页面直接使用app.json中的默认配置。</p>
<p>logs的页面结构</p>
<pre><code>&lt;!--logs.wxml--&gt;
&lt;view class=&quot;container log-list&quot;&gt;
  &lt;block wx:for=&quot;{{logs}}&quot; wx:for-item=&quot;log&quot;&gt;
    &lt;text class=&quot;log-item&quot;&gt;{{index + 1}}. {{log}}&lt;/text&gt;
  &lt;/block&gt;
&lt;/view&gt;
</code></pre><p>logs页面使用<block>控制标签来组织代码，在<block>上使用wx:for绑定logs数据，并将logs数据循环展开节点</block></block></p>
<pre><code>//logs.js
const util = require(&#39;../../utils/util.js&#39;)

Page({
  data: {
    logs: []
  },
  onLoad: function () {
    this.setData({
      logs: (wx.getStorageSync(&#39;logs&#39;) || []).map(log =&gt; {
        return util.formatTime(new Date(log))
      })
    })
  }
})
</code></pre><p>运行结果如下:<br><img src="http://www.uiyin.com/tuku/weixin/FirstDay/firstDay4.png" alt="运行结果"></p>
<h2 id="手机预览"><a href="#手机预览" class="headerlink" title="手机预览"></a>手机预览</h2><p>开发者工具左侧菜单栏选择”项目”点击预览，扫码后即可在微信客户端中体验。<br><img src="http://www.uiyin.com/tuku/weixin/FirstDay/firstDay4.png" alt="运行结果"></p>
]]></content>
      
        <categories>
            
            <category> 小程序 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 小程序 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Js基础用法]]></title>
      <url>/12/JsBasic/</url>
      <content type="html"><![CDATA[<p>通过本节的学习，主要掌握到Js的常态知识点。重点掌握的是思想。获取DOM，封装函数。以及FOR循环的思想</p>
<h2 id="JS效果三要素"><a href="#JS效果三要素" class="headerlink" title="JS效果三要素:"></a>JS效果三要素:</h2><h3 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h3><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><h3 id="运动轨迹-分步骤来实现先死后活法逐步来"><a href="#运动轨迹-分步骤来实现先死后活法逐步来" class="headerlink" title="运动轨迹(分步骤来实现先死后活法逐步来)"></a>运动轨迹(分步骤来实现先死后活法逐步来)</h3><hr>
<h2 id="获取元素三种途径"><a href="#获取元素三种途径" class="headerlink" title="获取元素三种途径 :"></a>获取元素三种途径 :</h2><ul>
<li>getElementById()—-静态方法,前面只能跟随document</li>
<li>document.body,document.title —-页面上只有一个的元素</li>
<li>getElementsByTagName()—–动态方法,前面可以是document也可以跟其他元素，返回的是一个类似数组的集合<br>(1)有类似数组的length<br>(2)有类似数组的应用方式例如:ali[0]<br>(3)再用TagName的时候必须要加上[]<br>(4)所谓的动态方法,是指通过js动态添加的元素，getElementsByTagName()也可以找到<br>   但是document.getElementById是找不到的</li>
</ul>
<h2 id="事件-1"><a href="#事件-1" class="headerlink" title="事件:"></a>事件:</h2><h3 id="事件-鼠标事件，键盘事件-系统事件-表单事件-自定义事件等等"><a href="#事件-鼠标事件，键盘事件-系统事件-表单事件-自定义事件等等" class="headerlink" title="事件:鼠标事件，键盘事件,系统事件,表单事件,自定义事件等等"></a>事件:鼠标事件，键盘事件,系统事件,表单事件,自定义事件等等</h3><ul>
<li>onclick</li>
<li>onmouseover</li>
<li>onmouseleave</li>
<li>onmousedown</li>
<li>onmouseout</li>
<li>onmouseup</li>
<li>onmousemove</li>
<li>……</li>
</ul>
<h3 id="添加事件"><a href="#添加事件" class="headerlink" title="添加事件"></a>添加事件</h3><p>元素.onmouseover</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数可以理解为方法,工具比如</p>
<pre><code>&lt;html&gt;
&lt;script&gt;
function abc(){
  /*要做的事情*/
}
&lt;/script&gt;
&lt;/html&gt;
</code></pre><ul>
<li>直接调用就是abc()</li>
<li>事件调用: 元素.事件 = 函数名</li>
<li>匿名函数</li>
</ul>
<pre><code>&lt;html&gt;
&lt;script&gt;
  元素.onmouseover = function(){}
  window.alert(1);  window.alert(&quot;ok&quot;);
&lt;/script&gt;
&lt;/html&gt;
</code></pre><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量就是变化的量,由数字，字母，下划线，美元($)组成.但是开头不能用数字。定义一个变量必须用var也可以用window[“xxx”]</p>
<ul>
<li>var li = document.getElementById(“list”);</li>
<li>var num = 123;</li>
<li>var name = “leo”;</li>
</ul>
<h2 id="JS属性操作-重点"><a href="#JS属性操作-重点" class="headerlink" title="JS属性操作(重点)"></a><a href="">JS属性操作</a>(重点)</h2><ul>
<li>属性名</li>
<li>属性值</li>
<li>属性的读取操作:获取,找到元素.属性名</li>
<li>属性的写操作:替换，修改 元素.属性名 = 新的值 添加的话需要用+=</li>
<li>innerHTML读取元素内所有的HTML代码</li>
</ul>
<h3 id="属性读写操作的注意事项"><a href="#属性读写操作的注意事项" class="headerlink" title="属性读写操作的注意事项"></a>属性读写操作的注意事项</h3><ul>
<li>JS属性中不允许出现”-“,例如font-size改为fontSize</li>
<li>class在JS里面是保留字,在JS作用class要用className</li>
<li><p>4个绝对不要判断<br>1.相对路径(src ,href)<br>2.颜色值<br>3.innerHTML值也不要(IE678可能有空格)<br>4.type类型也不要判断.因为IE678下面type更改不了</p>
</li>
<li><p>中括号[]的使用</p>
<ol>
<li>点”.”后面的值无法修改</li>
<li>[]里面的值可以修改,JS允许把.替换成[] 例如style[attr]这样的</li>
</ol>
</li>
</ul>
<h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><h3 id="if"><a href="#if" class="headerlink" title="if(){}"></a>if(){}</h3><h3 id="if-else"><a href="#if-else" class="headerlink" title="if(){}else{}"></a>if(){}else{}</h3><h3 id="if-else-if-else-if"><a href="#if-else-if-else-if" class="headerlink" title="if(){}else if(){}else if(){}"></a>if(){}else if(){}else if(){}</h3><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul>
<li>放数据的仓库</li>
<li>中括号[],间隔用逗号,最后一个数据不要加逗号</li>
<li>数组的length属性</li>
</ul>
<h2 id="自定义索引和属性"><a href="#自定义索引和属性" class="headerlink" title="自定义索引和属性"></a><a href="">自定义索引和属性</a></h2><p>自定义属性  abtn[0].abc = 123;   //自定义属性<br>自定义属性赋值 obj.timer = setInterval(function(){},1000);   //自定义属性赋值</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a><a href="">数据类型</a></h2><h2 id="6大类"><a href="#6大类" class="headerlink" title="6大类"></a>6大类</h2><ul>
<li>空</li>
<li>对象</li>
<li>undefined</li>
<li>Boolean</li>
<li>String</li>
<li>number</li>
</ul>
<blockquote>
<p>(1)要是基础类型可以用typeOf()来判断字符串方法charAt(),获取到字符串第几个charCodeAt()获取到UniCode编码。然后在计算。再利用fromCharCode()换算成字符<br>(2)要是引用类型可以用instanceOf Array;instanceOf Object 来判断<br>Number()方法能转化字符串数字，空，空数组，要是前面有0比如00100转化的结果就是100<br>parseInt()相当于把前面的数字部分转化为数字，后面的字符直接舍弃.他转化不了空，真要是转化空结果就是NaN<br>parseFloat()同上<br>isNaN()判断是不是NaN</p>
</blockquote>
<h2 id="作用域重点"><a href="#作用域重点" class="headerlink" title="作用域重点"></a><a href="">作用域重点</a></h2><ul>
<li>域：空间，范围，区域</li>
<li>作用:读，写</li>
</ul>
<blockquote>
<p>(1)在JS找到变量前，他要做的就是先找到一些关键字 var function,参数然后在正是运行代码之前他把这些都提前付了一个值,undefined<br>遇到重名的只留一个<br>(2)逐行解读代码。每读一行就是到库里面去看看，要是有值就替换，改变表达式的值</p>
</blockquote>
<pre><code>&lt;html&gt;
&lt;script&gt;
alert(a); //弹出：function a(){alert(4);}
var a=1; //预解析中的a改为了1
alert(a);  //弹出1
function a(){alert(2);}//函数声明，没有改变a的值。什么也没发生。
alert(a); //继续弹出1，因为a在预处理库里面的值没有被改过。
var a=3; //预处理中a的值变为3
alert(a); //弹出3
function a(){alert(4);} //函数声明，什么也没有发生
alert(a); //继续弹出3
a(); //报错 a is not a function
第一步:
       预编译他会先找一些关键字存储到内存中。 比如var function 参数等等
       他找到var a 先看左边，不看右边.上来都给他一个未定义 var a = undefined;要是function他就直接替换了
       比如上面a从undefined直接变成了方法
       他根本不考虑后面的值
第二步:
        在一步步执行代码
        要是遇见表达式（表达式就是 var a = xxx）他才会重新替换或者赋值

&lt;/script&gt;
&lt;/html&gt;
</code></pre><h2 id="函数的作用域要区分全局变量和局部变量"><a href="#函数的作用域要区分全局变量和局部变量" class="headerlink" title="函数的作用域要区分全局变量和局部变量"></a>函数的作用域要区分全局变量和局部变量</h2><p>在方法内部写var的都是局部。在方法外面的都是全局变量。要是在方法里面不加var,那他改变的就是全局的值.</p>
<h3 id="特别注意的就是在JS里面只有方法有作用域。for和if里面都没有作用域"><a href="#特别注意的就是在JS里面只有方法有作用域。for和if里面都没有作用域" class="headerlink" title="特别注意的就是在JS里面只有方法有作用域。for和if里面都没有作用域"></a>特别注意的就是在JS里面只有方法有作用域。for和if里面都没有作用域</h3><h2 id="真和假"><a href="#真和假" class="headerlink" title="真和假"></a><a href="">真和假</a></h2><ul>
<li>真:非0的数字,字符串,true,函数,object,[],{}都是真的</li>
<li>假:就记住6个为假其余都真 0,NaN,空字符串,null,false,undefined</li>
</ul>
<h2 id="函数返回值return"><a href="#函数返回值return" class="headerlink" title="函数返回值return"></a>函数返回值return</h2><h3 id="这里特别注意下"><a href="#这里特别注意下" class="headerlink" title="这里特别注意下:"></a>这里特别注意下:</h3><pre><code>&lt;html&gt;
&lt;scirpt&gt;
alert fn1();
function fn1(){
    return function(){
        alert(1);
    }
}
&lt;/script&gt;
&lt;/html&gt;
</code></pre><h4 id="返回的值就是function-alert-1"><a href="#返回的值就是function-alert-1" class="headerlink" title="返回的值就是function(){alert(1)}"></a>返回的值就是function(){alert(1)}</h4><pre><code>&lt;html&gt;
&lt;scirpt&gt;
alert fn1()();
function fn1(){
    return function(){
        alert(1);
    }
}
&lt;/script&gt;
&lt;/html&gt;
</code></pre><h4 id="返回的值就是1"><a href="#返回的值就是1" class="headerlink" title="返回的值就是1"></a>返回的值就是1</h4><h2 id="arguments参数合集"><a href="#arguments参数合集" class="headerlink" title="arguments参数合集"></a>arguments参数合集</h2><h3 id="arguments表示所有的参数合集"><a href="#arguments表示所有的参数合集" class="headerlink" title="arguments表示所有的参数合集"></a>arguments表示所有的参数合集</h3><pre><code>&lt;html&gt;
&lt;script&gt;
lert(sum(1,2,3));
function sum(){
    var n=0;
    for(var i=0; i&lt;arguments.length; i++){
        n += arguments[i];
    }
    return n;
}
&lt;/script&gt;
&lt;/html&gt;
</code></pre><h2 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h2><h3 id="获取到样式"><a href="#获取到样式" class="headerlink" title="获取到样式"></a>获取到样式</h3><pre><code>&lt;html&gt;
&lt;scirpt&gt;
function getStyle(obj,attr)
{
  return obj.currentStyle?obj.currentStyle[attr]:getComputedStyle(obj)[attr]
}
&lt;/script&gt;
&lt;html&gt;
</code></pre><h3 id="兼容IE678-获取到样式合集-获取到元素的属性值"><a href="#兼容IE678-获取到样式合集-获取到元素的属性值" class="headerlink" title="兼容IE678 获取到样式合集.获取到元素的属性值"></a>兼容IE678 获取到样式合集.获取到元素的属性值</h3><pre><code>&lt;html&gt;
&lt;script&gt;
运动函数
//封装运动函数
    //既然是运动函数就需要传递几个条件(参数)
    // 1.对象(你得知道让谁动吧)
    // 2.方向(你得告诉他朝哪边走吧)
    // 3.速度 (你得告诉他一次走多少吧)
    // 4.终点(你得告诉他什么时候停止吧)
    // 5.回调函数(到达终点以后干点什么吧)
    function Imove(obj,attr,step,target,endfn)
    {
        //防止累加,越来越快。这样一上来我都从0开始计算
        clearTimeout(obj.timer);
        //主要是判断速度是正的还是负的，上来先比较。我的思路是要是目标的位置比初始的位置大，则速度肯定是正的，要是小则速度肯定是负的
        step =  target&gt;parseInt(getStyle(obj,attr))? step:-step;
        obj.timer = setInterval(function(){
            var dis = parseInt(getStyle(obj,attr))+step;   //获取到每次走了之后距离最开始的位置
            //判断一下当走的距离要是超过了终点，则必须拉回来。要是没超过。则继续走.
            if(dis&gt;=target&amp;&amp;step&gt;0||dis&lt;target&amp;&amp;step&lt;0)
            {
                dis = target;
            }
            obj.style[attr] = dis+&quot;px&quot;;   //给这个对象赋值，让他自己慢慢走。
            if(dis==target)               //当到达了终点了，就不让他走了。这个时候你需要清除定时器了。因为没用了。
            {
                clearInterval(obj.timer);   //清除定时器
                endfn&amp;&amp;endfn();           //执行回调方法
            }
        },100)
    }
    //封装运动函数结束
    &lt;/script&gt;
    &lt;/html&gt;
</code></pre><h3 id="下面是抖动函数封装"><a href="#下面是抖动函数封装" class="headerlink" title="下面是抖动函数封装"></a>下面是抖动函数封装</h3><pre><code>&lt;html&gt;
&lt;script&gt;
抖动函数封装
function shake(obj,attr,endfn) {
        var arr = [];
        for (var i = 20; i &gt; 0; i -= 2)
        {
            arr.push(i,-i);
        }
        arr.push(0);
        clearInterval(obj.shaker);
        var index = 0 ;
        obj.shaker = setInterval(function(){
            var speed = (parseInt(getStyle(obj,attr))+arr[index]);
            obj.style[attr] = speed +&quot;px&quot;;
            ++index;
            if(index==arr.length)
            {
                clearInterval(obj.shaker);
                endfn&amp;&amp;endfn();
            }
        },10)
    }
&lt;/script&gt;
&lt;/html&gt;
</code></pre><h3 id="下面是滤镜opacity函数封装"><a href="#下面是滤镜opacity函数封装" class="headerlink" title="下面是滤镜opacity函数封装"></a>下面是滤镜opacity函数封装</h3><pre><code>&lt;html&gt;
&lt;script&gt;
function doopacity(obj,step,target,endfn)
    {
      var first = getStyle(obj,&quot;opacity&quot;)*100;  //获取到滤镜的初始值
       step = target&gt;first?step:-step;    //一步走的距离是正的是负的
        clearInterval(obj.opacity);       //一上来清除定时器。防止累加
         obj.opacity = setInterval(function(){
           var speed = getStyle(obj,&quot;opacity&quot;)*100+step;     //改变opacity
           if(speed&gt;=target&amp;&amp;step&gt;0&amp;&amp;speed&lt;=target&amp;&amp;step&lt;0)
           {
               speed = target;        //变成目标值
           }
           if(speed==target)
           {
               clearInterval(obj.opacity);   //要是相当则清空
               endfn&amp;&amp;endfn();                //执行回调函数
           }
             obj.style[&quot;opacity&quot;] = speed/100;   //DIV滤镜效果
             obj.style.filter = &#39;alpha(opacity:&#39; + speed + &#39;)&#39;;  //为了兼容性
        },100)
    }
&lt;/script&gt;
&lt;/html&gt;
</code></pre><h3 id="时间函数"><a href="#时间函数" class="headerlink" title="时间函数"></a>时间函数</h3><ul>
<li>getFullYear() //获取到年份</li>
<li>getMonth()   //这里特别注意的一定要+1因为他从0开始</li>
<li>getDate()   //获取到多少号</li>
<li>getDay()    //获取到星期几，得到是一个数值，要是星期天，则得到数字0</li>
<li>getHours()   //获取到小时</li>
<li>getMinutes()        //获取到分钟</li>
<li>getSeconds()  //获取到秒数</li>
</ul>
<hr>
<h3 id="Date对象参数"><a href="#Date对象参数" class="headerlink" title="Date对象参数"></a>Date对象参数</h3><h4 id="数字形式-new-Date-2014-4-1-9-48-12-特别注意月份从0开始，所以他实际找的是5月"><a href="#数字形式-new-Date-2014-4-1-9-48-12-特别注意月份从0开始，所以他实际找的是5月" class="headerlink" title="数字形式:new Date(2014,4,1,9,48,12)  //特别注意月份从0开始，所以他实际找的是5月"></a>数字形式:new Date(2014,4,1,9,48,12)  //特别注意月份从0开始，所以他实际找的是5月</h4><pre><code>&lt;html&gt;
&lt;script&gt;
var iNow = new Date();
var iNew = new Date(2014, 10, 26, 21, 56, 0);  //获取的是11月
var t = Math.floor((iNew - iNow)/1000); 
var str = Math.floor(t/86400) + &#39;天&#39; +  Math.floor(t%86400/3600) + &#39;时&#39; + Math.floor(t%86400%3600/60) + &#39;分&#39; +  t%60 + &#39;秒&#39;;
&lt;/script&gt;
&lt;/html&gt;
</code></pre><ul>
<li>天: Math.floor(t/86400);</li>
<li>时: Math.floor(t%86400/3600);</li>
<li>分:Math.floor(t%86400%3600/60);</li>
<li>秒:Math.floor(t%60);</li>
</ul>
<h3 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h3><h4 id="getTime-返回的就是格林威治时间1970年-1月1日0点0分0秒0毫秒到现在的毫秒数"><a href="#getTime-返回的就是格林威治时间1970年-1月1日0点0分0秒0毫秒到现在的毫秒数" class="headerlink" title="getTime();返回的就是格林威治时间1970年 1月1日0点0分0秒0毫秒到现在的毫秒数"></a>getTime();返回的就是格林威治时间1970年 1月1日0点0分0秒0毫秒到现在的毫秒数</h4><h2 id="字符串获取，封装，截取，查找，检测"><a href="#字符串获取，封装，截取，查找，检测" class="headerlink" title="字符串获取，封装，截取，查找，检测"></a>字符串获取，封装，截取，查找，检测</h2><ul>
<li>length 空格也算长度</li>
<li>charAt()找到子字符串，括号要是什么也不写。默认找到第0个</li>
<li>charCodeAt()得到指定字符串的unicode编码</li>
<li>String.fromCharCode():根据字符编码。返回一个字符。例如:String.fromCharCode(22937);返回的就是妙字</li>
<li>要是想获取到多个，可以String.fromCharCode(22937,22938);</li>
</ul>
<hr>
<h3 id="查找indexOf-lastIndexOf"><a href="#查找indexOf-lastIndexOf" class="headerlink" title="查找indexOf,lastIndexOf"></a>查找indexOf,lastIndexOf</h3><ul>
<li>indexof()返回某个字符或字符串的位置.string.indexOf(‘m’,5)代表从str字符串中的第5位开始以后找到m的位置.如果要是找不到则返回-1</li>
<li>lastIndexOf()从右边往前找，也可以带数字参数，表示从哪里找</li>
</ul>
<hr>
<h3 id="比较类，截取类"><a href="#比较类，截取类" class="headerlink" title="比较类，截取类"></a>比较类，截取类</h3><ul>
<li>substring(n,m)表示从第n截取，到第m位置结束.如果没有m默认截取到最后一位,包前不包后.</li>
<li>slice(n,m),str.slice(0,2)与str.slice(2,0)这样的结果完全不一样。后者找不到结果。因为slice()方法不会判断里面的参数大小并交换参数位置.</li>
<li>slice(-2);截取的是从最后一位到倒数第二位,-1表示的最后一位.str.slice(-4,-2);截取的是倒数第四位到倒数第二位</li>
</ul>
<hr>
<ul>
<li>toUpperCase()转换为大写</li>
<li>toLowerCase()转换为小写</li>
<li>split()讲字符串切割成数组</li>
</ul>
<pre><code>&lt;html&gt;
&lt;scirpt&gt;
var str = &#39;www.miaov.com&#39;;
str.split(&#39;.&#39;); =&gt; [“www”, “miaov”, “com”];
var str1 = &#39;leo&#39;; 
str1.split(); =&gt; [&#39;leo&#39;];
str2 = ‘leo’; 
str2.split(‘’); =&gt; [“l”, “e”, “o”]；
var str3 = ‘/www.miaov.com/’; 
str3.split(‘/’); =&gt; [””, “www.miaov.com”, “”]；
var str4 = ‘2013-11-29-23-07’;
str4.split(‘-‘, 3); =&gt; [“2013”, “11”, “29”]
&lt;/script&gt;
&lt;/html&gt;
</code></pre><h3 id="join方法用来把数组变成字符串"><a href="#join方法用来把数组变成字符串" class="headerlink" title="join方法用来把数组变成字符串"></a><a href="">join方法用来把数组变成字符串</a></h3><pre><code>&lt;html&gt;
&lt;script&gt;
var arr = [‘aa’, ‘bb’, ‘cc]; 
arr.join(); =&gt; ‘aa,bb,cc’ .join()括号中什么也不写，默认就是用逗号隔开。
arr.join(‘’); =&gt; ‘aabbcc’ ；
 arr.join(‘-‘); =&gt; ‘aa-bb-cc’
 &lt;/script&gt;
 &lt;/html&gt;
</code></pre><hr>
<h3 id="下面是所有的字符串操作总结"><a href="#下面是所有的字符串操作总结" class="headerlink" title="下面是所有的字符串操作总结"></a>下面是所有的字符串操作总结</h3><pre><code>&lt;html&gt;
&lt;script&gt;
var str = &#39;妙味课堂-WWW.miaov.com&#39;;

str.charAt(1); //味
str.charCodeAt(1); //21619
String.fromCharCode(22937, 21619); //妙味

str.indexOf(&#39;m&#39;, 3); //9
str.lastIndexOf(&#39;o&#39;); //16

&#39;1000&#39; &lt; &#39;2&#39; //true
&#39;1000&#39; &gt; 2 //true

str.substring(0, 4); //妙味课堂
str.slice(-3); //&#39;com&#39;

str.toUpperCase(); //&#39;妙味课堂-WWW.MIAOV.COM&#39;
str.toLowerCase(); //&#39;妙味课堂-www.miaov.com&#39;

str.split(&#39;.&#39;, 2); //[&#39;秒微课堂-www&#39;, &#39;miaov&#39;]

var arr = [&#39;www&#39;, &#39;miaov&#39;, &#39;com&#39;];
arr.join(&#39;.&#39;); //&#39;www.miaov.com&#39;
&lt;/script&gt;
&lt;/html&gt;
</code></pre><hr>
<h3 id="for-in-循环遍历json因为json是个对象。没有长度。类似键值对。循环的是属性"><a href="#for-in-循环遍历json因为json是个对象。没有长度。类似键值对。循环的是属性" class="headerlink" title="for-in 循环遍历json因为json是个对象。没有长度。类似键值对。循环的是属性"></a>for-in 循环遍历json因为json是个对象。没有长度。类似键值对。循环的是属性</h3><pre><code>&lt;html&gt;
&lt;script&gt;
var json4 = { &#39;name&#39;: &#39;miaov&#39;, &#39;age&#39;: 3, &#39;fun&#39;: &#39;前端开发&#39;};
for(var attr in json4){
    alert(attr);
    alert(json4[attr]);
}

var json5 = { 
    url: [&#39;img/1.png&#39;, &#39;img/2.png&#39;],
    text: [&#39;图片一&#39;, &#39;图片二&#39;]
};

for(var attr in json5) {
    for(var i=0; i&lt;json5[attr].length; i++){
        alert(json5[attr][i]);
    }
}
&lt;/script&gt;
&lt;/html&gt;
</code></pre><hr>
<h2 id="数组-1"><a href="#数组-1" class="headerlink" title="数组"></a>数组</h2><ul>
<li>可以通过修改数组的length属性来清空数组。</li>
<li>从后面添加数组push() arr.push()往数组最后一位加内容..push()方法是有返回值得。返回是数组的新长度</li>
<li>前面添加数组unshift() arr.unshift()往数组的最前面添加内容，返回值为数组的新长度(IE6,7不支持)</li>
<li>删除pop() arr.pop()表示从后面删除一个数组元素。返回值就是要删除的数组</li>
<li>删除shift() arr.shift()删除数组的第一个返回值是被扔掉的值</li>
</ul>
<pre><code>&lt;html&gt;
&lt;script&gt;
var arr = [&#39;TM&#39;, &#39;钟毅&#39;, &#39;张森&#39;, &#39;杜鹏&#39;, &#39;Leo&#39;];
arr.unshift(arr.pop()); //数组变为：[&#39;Leo&#39;, &#39;钟毅&#39;, &#39;张森&#39;, &#39;杜鹏&#39;, &#39;TM&#39;]
或
arr.push(arr.shift()); //数组变为：[&#39;钟毅&#39;, &#39;张森&#39;, &#39;杜鹏&#39;, &#39;Leo&#39;, &#39;TM&#39;]
&lt;/script&gt;
&lt;/html&gt;
</code></pre><h3 id="splice-方法"><a href="#splice-方法" class="headerlink" title="splice()方法"></a>splice()方法</h3><h4 id="splice-a-b-c-a表示起始位置-b表示个数-c表示要替换的值-b要是为0表示插入，c要是什么也不写表示删除。"><a href="#splice-a-b-c-a表示起始位置-b表示个数-c表示要替换的值-b要是为0表示插入，c要是什么也不写表示删除。" class="headerlink" title="splice(a,b,c) a表示起始位置,b表示个数,c表示要替换的值.b要是为0表示插入，c要是什么也不写表示删除。"></a>splice(a,b,c) a表示起始位置,b表示个数,c表示要替换的值.b要是为0表示插入，c要是什么也不写表示删除。</h4><hr>
<h3 id="代码见下"><a href="#代码见下" class="headerlink" title="代码见下"></a>代码见下</h3><pre><code>&lt;html&gt;
&lt;script&gt;
var arr = [&#39;TM&#39;, &#39;钟毅&#39;, &#39;张森&#39;, &#39;杜鹏&#39;, &#39;Leo&#39;];
//删除
//arr.splice(0, 1); //删掉第0位，删1个。两个参数第一个是从第几位开始，第二个是删掉几个。splice删除的时候有返回值，返回的是被删除的内容
//替换
//arr.splice(0, 1, &#39;莫涛&#39;); //替换第0位，替换1个，替换为&#39;莫涛&#39;。返回的还是删除的东西
//添加
arr.splice(1, 0, &#39;李贤&#39;); //在第1位那里，删除0个，添加了一个&#39;李贤&#39;到了第1位，&#39;钟毅&#39;就变成了arr[2]了。后面也可以添加多个。如果splice删除了0个，那么就没有返回值。
&lt;/script&gt;
&lt;/html&gt;
</code></pre><hr>
<h3 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h3><pre><code>&lt;html&gt;
&lt;script&gt;
var arr = [1, 2, 2, 4, 2];
for ( var i=0; i&lt;arr.length; i++ ) {
    for ( var j = i+1; j&lt;arr.length; j++) {
        if( arr[i]==arr[j] ){
            arr.splice( j, 1 );
            j--;
        }
    }
}
也可以使用indexOf
&lt;/script&gt;
&lt;/html&gt;
</code></pre><hr>
<h3 id="Sort排序"><a href="#Sort排序" class="headerlink" title="Sort排序"></a>Sort排序</h3><pre><code>&lt;html&gt;
&lt;script&gt;
var arr = [&#39;c&#39;, &#39;d&#39;, &#39;a&#39;, &#39;e&#39;];
arr.sort(); // &#39;a&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39; 按照unicode编码排序

var arr2 = [4, 3, 5, 76, 2, 0, 8];
// arr2.sort(); // 0, 2, 3, 4, 5, 76, 8 sort默认是将数组中的每一个按照字符串来排序的，因此出现了76排在8前面的情况

// arr2. sort(function( a, b ){
    return a - b; //如果a-b返回正数，就a、b两个数字换个序。如果a-b是负数，就不换序
}) //返回数字从小到大 0, 2, 3, 4, 5, 8, 76

// arr2. sort(function( a, b ){
    return b - a;
}) //返回数字从大到小 76,, 8, 5, 4, 3, 2, 0
&lt;/script&gt;
&lt;/html&gt;
</code></pre><hr>
<h3 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h3><h4 id="Math-round-Math-random-80-20-返回20-100之间的随机整数"><a href="#Math-round-Math-random-80-20-返回20-100之间的随机整数" class="headerlink" title="Math.round( Math.random()*80 + 20 ); //返回20~100之间的随机整数"></a>Math.round( Math.random()*80 + 20 ); //返回20~100之间的随机整数</h4><hr>
<h3 id="connect连接-表示把2个数组拼接起来"><a href="#connect连接-表示把2个数组拼接起来" class="headerlink" title="connect连接,表示把2个数组拼接起来"></a>connect连接,表示把2个数组拼接起来</h3><pre><code>&lt;html&gt;
&lt;script&gt;
var arr1 = [1, 2, 3];
var arr2 = [4, 5, 6];
var arr3 = [7, 8, 9];

arr1.concat(arr2); //[1, 2, 3, 4, 5, 6] 新数组与原来数组没什么关系。
arr1.concat(arr2, arr3); //[1, 2, 3, 4, 5, 6, 7, 8, 9]
&lt;/script&gt;
&lt;/html&gt;
</code></pre><h3 id="reverse反转"><a href="#reverse反转" class="headerlink" title="reverse反转"></a>reverse反转</h3><pre><code>&lt;html&gt;
&lt;script&gt;
var arr1 = [1, 2, 3];
arr1.reverse();
alert(arr1); // [3, 2, 1]
&lt;/script&gt;
&lt;/html&gt;
</code></pre><h2 id="以上JS基础全部基础点"><a href="#以上JS基础全部基础点" class="headerlink" title="以上JS基础全部基础点"></a>以上JS基础全部基础点</h2><h3 id="对应的链接是"><a href="#对应的链接是" class="headerlink" title="对应的链接是:"></a>对应的链接是:</h3><p><a href="https://youngjudge.github.io/JsBasic/" target="_blank" rel="external">基础知识点所有效果点击这里</a></p>
]]></content>
      
        <categories>
            
            <category> Js基础用法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Js基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MarkDown]]></title>
      <url>/09/MarkDown/</url>
      <content type="html"><![CDATA[<p>本节主要是介绍 Markdown语法的使用，里面介绍了关于Markdown的大致用法,方便后期记忆</p>
<h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>   标题一对应的就是#标题<br>   标题二对应的就是##标题</p>
<blockquote>
<p>这里特别注意的就是标题二经常使用<br>因为他自己会加下划线</p>
</blockquote>
<p>   标题三对应的就是###标题<br>   标题四对应的就是####标题<br>   标题五对应的就是#####标题<br>   标题六对应的就是######标题<br>   标题一的字体最大，标题六的字体最小。一般情况下使用标题二</p>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>列表里面分为2种<br>第一种是无序列表<br>第二种是有序列表</p>
<h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><ul>
<li>第一个无序列表(无序列表就是*加空格)</li>
<li>第二个无序列表(无序列表就是*加空格)</li>
<li>第三个无序列表(无需列表就是*加空格)</li>
</ul>
<h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><ol>
<li>有序列表第一个(就是序号加.加空格比如1.+空格)</li>
<li>有序列表第二个(就是序号加.加空格比如2.+空格)</li>
<li>有序列表第三个(就是序号加.加空格比如3.+空格)</li>
</ol>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><blockquote>
<p>这一段就是引用<br>可能颜色有点浅。但是后期能调。不过我习惯了.<br>引用的符号就是&gt;后面加文字<br>引用要是想结束就是回车加换行</p>
</blockquote>
<h2 id="代码框"><a href="#代码框" class="headerlink" title="代码框"></a>代码框</h2><blockquote>
<p>代码框的引入就是被3个`前后包起来即可。</p>
</blockquote>
<pre><code>&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;JS测试第一篇&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id=&quot;div1&quot; style=&quot;background:red;width:100px;height:100px&quot;&gt;&lt;/div&gt;
&lt;button id=&quot;btn1&quot;&gt;点击我&lt;/button&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>图片的格式就是<img src="https://ss1.bdstatic.com/5eN1bjq8AAUYm2zgoY3K/r/www/cache/static/protocol/https/soutu/img/camera_new_5606e8f.png" alt="图片的名称"><br>调用本地的图片格式就是</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3709419-d635c2c09c3b9034.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.png"></p>
<blockquote>
<p>调用的法则就是![图片的名称]+(图片的地址)<br>要是调用本地的图片就是(![图片名称]+(本地图片地址。要是不知道可以直接把图片拖拽到浏览器里))</p>
</blockquote>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><blockquote>
<p>调用法则就是[链接的名称]+(链接的地址)他和图片比起来就少了一个感叹号</p>
</blockquote>
<h2 id="粗体和斜体"><a href="#粗体和斜体" class="headerlink" title="粗体和斜体"></a>粗体和斜体</h2><p>粗体就是文字被2个星号包裹起来比如:<strong>粗体</strong><br>斜体就是文字被一个星号包裹起来<em>斜体</em><br>你要是又要粗体又要斜体只有<strong><em>文字</em></strong><br>让内容被3个星号包裹起来</p>
<h2 id="Tab用来缩进"><a href="#Tab用来缩进" class="headerlink" title="Tab用来缩进"></a>Tab用来缩进</h2><p>一大段文字前面要是想缩进就可以按Tab键，这样直接就缩进了。还有边框。省时省力。</p>
<h2 id="这个时候你要是需要一条分割线"><a href="#这个时候你要是需要一条分割线" class="headerlink" title="这个时候你要是需要一条分割线"></a>这个时候你要是需要一条分割线</h2><hr>
<p>三个星号表示的就是分割线。</p>
<h2 id="以上就是Markdown最浅显的使用指南。"><a href="#以上就是Markdown最浅显的使用指南。" class="headerlink" title="以上就是Markdown最浅显的使用指南。"></a>以上就是Markdown最浅显的使用指南。</h2><p>一共11个标签方便各位能够更好的记录</p>
<h2 id="备注"><a href="#备注" class="headerlink" title="备注:"></a>备注:</h2><ol>
<li>windows环境下个人建议用Haroopad-v0.13.1-win-ia32.msi</li>
<li>在 Mac OS X 上，我强烈建议你用 Mou 这款免费且十分好用的 Markdown 编辑器</li>
<li>在IOS上 Ulysses for iPad</li>
<li>Web端请使用简书</li>
</ol>
]]></content>
      
        <categories>
            
            <category> MarkDown语法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
        
    </entry>
    
  
  
    
    <entry>
      <title><![CDATA[图库]]></title>
      <url>/gallery/index.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[友情链接]]></title>
      <url>/links/index.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[时光隧道]]></title>
      <url>/timeline/index.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[标签云]]></title>
      <url>/tags/index.html</url>
      <content type="html"></content>
    </entry>
    
  
</search>
